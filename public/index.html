<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>CPYA Map (Athens) ‚Äî v1.2</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --text:#e8eaed;
      --muted:#aab0bb;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 22px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
      --accent:#4aa3ff;
      --danger:#ff4d4d;
    }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #07080b; color: var(--text); }
    #app { height: 100%; position:relative; }
    #map { height: 100%; width: 100%; }

    .card{
      background: rgba(17,19,24,.92);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    #panel{
      position: relative;
      z-index: 2000;
      background: rgba(8,10,14,.75);
      border-bottom: 1px solid var(--line);
      padding: calc(10px + var(--safe-top)) 12px 10px;
    }

    #panelInner{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .input{
      flex: 1 1 220px;
      min-width: 160px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 16px;
      outline:none;
    }

    .btn{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn.primary{ background: rgba(74,163,255,.18); border-color: rgba(74,163,255,.35); }
    .btn.danger{ background: rgba(255,77,77,.14); border-color: rgba(255,77,77,.35); }

    .row{
      margin-top: 10px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    select{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 14px;
    }
    .small { font-size: 12px; color: var(--muted); }

    /* Suggestions dropdown */
    #suggestBox{
      position:absolute;
      top: calc(12px + var(--safe-top) + 52px);
      left: 12px;
      right: 12px;
      display:none;
      z-index: 2200;
      border-radius: 16px;
      overflow:hidden;
    }
    #suggestBox .item{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
      background: rgba(17,19,24,.96);
    }
    #suggestBox .item:last-child{ border-bottom:none; }
    #suggestBox .item:hover{ background: rgba(255,255,255,.06); }
    #suggestBox .sub{ font-size:12px; color: var(--muted); margin-top:3px; }

    /* Pills */
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--text);
      user-select:none;
      cursor:pointer;
      margin-right: 6px;
      margin-top: 6px;
      white-space:nowrap;
    }
    .pill:hover{ background: rgba(255,255,255,.10); }

    /* Results */
    #resultsWrap{ margin-top: 10px; display:none; }
    #resultsHeader{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom: 8px; }
    #resultsList{
      max-height: 240px;
      overflow:auto;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .res{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      cursor:pointer;
    }
    .res:last-child{ border-bottom:none; }
    .res:hover{ background: rgba(255,255,255,.06); }
    .res.selected{ background: rgba(74,163,255,.16); outline: 1px solid rgba(74,163,255,.35); }
    .resTitle{ font-size: 14px; font-weight: 800; }
    .resMeta{ font-size: 12px; color: var(--muted); margin-top: 3px; }

    /* Loading */
    #loadingOverlay{
      position: fixed; inset: 0;
      display:none;
      align-items:center; justify-content:center;
      z-index: 5000;
      background: rgba(0,0,0,.40);
      backdrop-filter: blur(3px);
    }
    .loaderCard{
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(17,19,24,.92);
      box-shadow: var(--shadow);
      display:flex; align-items:center; gap:12px;
      max-width: 92vw;
    }
    .spinner{
      width: 18px; height: 18px;
      border: 2px solid rgba(255,255,255,.2);
      border-top-color: rgba(255,255,255,.9);
      border-radius: 999px;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Toasts */
    #toastWrap{
      position: fixed;
      top: calc(12px + var(--safe-top));
      left: 50%;
      transform: translateX(-50%);
      z-index: 6000;
      display:flex;
      flex-direction:column;
      gap:8px;
      width: min(520px, 92vw);
      pointer-events:none;
    }
    .toast{
      pointer-events:auto;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(17,19,24,.92);
      box-shadow: var(--shadow);
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .toast .tTitle{ font-size: 13px; font-weight: 800; margin-bottom: 2px; }
    .toast .tMsg{ font-size: 13px; color: var(--muted); }
    .toast .x{ margin-left:auto; cursor:pointer; opacity:.8; user-select:none; }
    .toast.info{ border-color: rgba(74,163,255,.35); }
    .toast.bad{ border-color: rgba(255,77,77,.35); }
    .toast.ok{ border-color: rgba(0,208,132,.35); }

    /* Weather */
    #weatherCard{
      position: fixed;
      left: 12px;
      bottom: calc(12px + var(--safe-bottom));
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 16px;
      display:none;
      min-width: 180px;
      max-width: min(320px, 80vw);
    }
    #weatherCard .line{ font-size: 13px; color: var(--muted); margin-top: 2px; }
    #weatherCard .big{ font-size: 18px; font-weight: 900; }
    #weatherCard .tiny{ font-size: 11px; color: var(--muted); margin-top: 6px; }

    /* Nav card */
    #navCard{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(12px + var(--safe-bottom));
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 18px;
      display:none;
      width: min(580px, 92vw);
    }
    #navTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 6px; }
    #navInstr{ font-size: 15px; font-weight: 900; line-height: 1.2; }
    #navSub{ font-size: 12px; color: var(--muted); margin-top: 3px; }
    #navBtns{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top: 10px; }

    /* Mobile bottom sheet */
    @media (max-width: 720px){
      #panel{
        position: fixed;
        left: 0; right: 0; bottom: 0; top: auto;
        border-bottom: none;
        border-top: 1px solid var(--line);
        padding: 10px 12px calc(10px + var(--safe-bottom));
        background: rgba(8,10,14,.90);
        z-index: 2000;
        border-top-left-radius: var(--radius2);
        border-top-right-radius: var(--radius2);
      }
      #panelHandle{
        width: 44px;
        height: 5px;
        border-radius: 999px;
        background: rgba(255,255,255,.22);
        margin: 4px auto 10px;
      }
      #suggestBox{ top: auto; bottom: calc(10px + var(--safe-bottom) + 110px); }
      #weatherCard{ bottom: calc(12px + var(--safe-bottom) + 220px); }
      #navCard{ bottom: calc(12px + var(--safe-bottom) + 220px); }
    }

    /* Desktop panel on right */
    @media (min-width: 721px){
      #panel{
        position: fixed;
        top: calc(12px + var(--safe-top));
        right: 12px;
        left: auto;
        width: 400px;
        border: 1px solid var(--line);
        border-radius: var(--radius2);
        background: rgba(8,10,14,.80);
        padding: 12px;
      }
      #panelHandle{ display:none; }
      #suggestBox{
        top: 62px;
        left: 12px;
        right: 12px;
      }
    }
  </style>
</head>

<body>
  <div id="toastWrap"></div>

  <div id="loadingOverlay">
    <div class="loaderCard">
      <div class="spinner"></div>
      <div>
        <div style="font-weight:900">Working‚Ä¶</div>
        <div style="font-size:13px;color:var(--muted)" id="loadingText">Loading</div>
      </div>
    </div>
  </div>

  <div id="weatherCard" class="card"></div>

  <div id="navCard" class="card">
    <div id="navTop">
      <div>
        <div id="navInstr">‚Äî</div>
        <div id="navSub">‚Äî</div>
      </div>
      <button class="btn" id="navClose" title="End navigation">‚úï</button>
    </div>
    <div id="navBtns">
      <button class="btn" id="navPrev">‚óÄ Prev</button>
      <button class="btn primary" id="navNext">Next ‚ñ∂</button>
      <button class="btn" id="navVoice">üîà Voice: Off</button>
      <button class="btn" id="navFollow">üß≠ Follow: Off</button>
      <button class="btn" id="navCenter">üìç Center: Me</button>
    </div>
  </div>

  <div id="app">
    <div id="panel">
      <div id="panelHandle"></div>

      <div id="panelInner">
        <input id="q" class="input" placeholder="Search‚Ä¶" autocomplete="off" />
        <button id="btn" class="btn primary" type="button">Find</button>
        <button id="locBtn" class="btn" type="button">Live tracking: Off</button>
        <button id="togglePanel" class="btn" type="button" title="Collapse/expand">‚ñæ</button>
      </div>

      <div id="suggestBox" class="card"></div>

      <div id="panelBody">
        <div class="row">
          <select id="nearSel">
            <option value="cafe">‚òï Cafes near me</option>
            <option value="food">üçï Food near me</option>
            <option value="pharmacy">üíä Pharmacies near me</option>
            <option value="supermarket">üõí Supermarkets near me</option>
          </select>
          <button id="nearBtn" class="btn" type="button">Near me</button>

          <select id="modeSel">
            <option value="walking">üö∂ Walking</option>
            <option value="driving">üöó Driving</option>
          </select>

          <select id="voiceStyle">
            <option value="off">Voice: Off</option>
            <option value="soft">Voice: Soft</option>
            <option value="normal">Voice: Normal</option>
          </select>

          <button id="clearBtn" class="btn danger" type="button" style="display:none;">Clear</button>
          <span class="small" id="status">Ready</span>
        </div>

        <div id="chips"></div>

        <div id="resultsWrap">
          <div id="resultsHeader">
            <div style="font-weight:900">Results</div>
            <div class="small" id="resultsMeta">‚Äî</div>
          </div>
          <div id="resultsList"></div>
        </div>

        <div class="small" style="margin-top:10px; opacity:.9" id="offlineHint"></div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // =========================
    // Athens bounds
    // =========================
    const ATHENS_BBOX = { west: 23.45, south: 37.75, east: 24.25, north: 38.20 };
    const ATHENS_BOUNDS = L.latLngBounds([ATHENS_BBOX.south, ATHENS_BBOX.west],[ATHENS_BBOX.north, ATHENS_BBOX.east]);

    function inAthens(lat, lon) {
      return lon >= ATHENS_BBOX.west && lon <= ATHENS_BBOX.east &&
             lat >= ATHENS_BBOX.south && lat <= ATHENS_BBOX.north;
    }
    function clampToAthens(lat, lon){
      const clampedLat = Math.min(Math.max(lat, ATHENS_BBOX.south), ATHENS_BBOX.north);
      const clampedLon = Math.min(Math.max(lon, ATHENS_BBOX.west), ATHENS_BBOX.east);
      return { lat: clampedLat, lon: clampedLon };
    }

    // =========================
    // DOM
    // =========================
    const qEl = document.getElementById("q");
    const btn = document.getElementById("btn");
    const locBtn = document.getElementById("locBtn");
    const togglePanelBtn = document.getElementById("togglePanel");
    const panelBody = document.getElementById("panelBody");

    const nearSel = document.getElementById("nearSel");
    const nearBtn = document.getElementById("nearBtn");
    const modeSel = document.getElementById("modeSel");
    const voiceStyleSel = document.getElementById("voiceStyle");

    const statusEl = document.getElementById("status");
    const chipsEl = document.getElementById("chips");

    const resultsWrap = document.getElementById("resultsWrap");
    const resultsList = document.getElementById("resultsList");
    const resultsMeta = document.getElementById("resultsMeta");
    const clearBtn = document.getElementById("clearBtn");

    const suggestBox = document.getElementById("suggestBox");
    const loadingOverlay = document.getElementById("loadingOverlay");
    const loadingText = document.getElementById("loadingText");
    const toastWrap = document.getElementById("toastWrap");

    const weatherCard = document.getElementById("weatherCard");

    const navCard = document.getElementById("navCard");
    const navInstr = document.getElementById("navInstr");
    const navSub = document.getElementById("navSub");
    const navPrev = document.getElementById("navPrev");
    const navNext = document.getElementById("navNext");
    const navClose = document.getElementById("navClose");
    const navVoice = document.getElementById("navVoice");
    const navFollowBtn = document.getElementById("navFollow");
    const navCenter = document.getElementById("navCenter");

    const offlineHint = document.getElementById("offlineHint");

    // =========================
    // Random placeholder examples (60)
    // =========================
    const PLACEHOLDERS = [
      'Search: "lidl"', 'Search: "AB supermarket"', 'Search: "Œ£Œ∫ŒªŒ±Œ≤ŒµŒΩŒØœÑŒ∑œÇ"', 'Search: "pharmacy"',
      'Search: "œÜŒ±œÅŒºŒ±Œ∫ŒµŒØŒø"', 'Search: "ŒΩŒøœÉŒøŒ∫ŒøŒºŒµŒØŒø"', 'Search: "hospital"', 'Search: "souvlaki"',
      'Search: "Œ∫Œ±œÜŒ≠"', 'Search: "coffee"', 'Search: "gym"', 'Search: "piraeus port"',
      'Search: "metro"', 'Search: "œÉœÑŒ±Œ∏ŒºœåœÇ ŒºŒµœÑœÅœå"', 'Search: "bus stop"', 'Search: "œÉœÑŒ¨œÉŒ∑ ŒªŒµœâœÜŒøœÅŒµŒØŒøœÖ"',
      'Search: "kifisia"', 'Search: "marousi"', 'Search: "glyfada"', 'Search: "pagrati"',
      'Search: "kolonaki"', 'Search: "ilisia"', 'Search: "kallithea"', 'Search: "nea smyrni"',
      'Search: "kerameikos"', 'Search: "exarchia"', 'Search: "monastiraki"', 'Search: "syntagma"',
      'Search: "acropolis"', 'Search: "Œ†ŒªŒ¨Œ∫Œ±"', 'Search: "museum"', 'Search: "ŒºŒøœÖœÉŒµŒØŒø"',
      'Search: "police"', 'Search: "Œ±œÉœÑœÖŒΩŒøŒºŒØŒ±"', 'Search: "post office"', 'Search: "ŒïŒõŒ§Œë"',
      'Search: "bank"', 'Search: "ATM"', 'Search: "parking"', 'Search: "fuel"',
      'Search: "Œ≤ŒµŒΩŒ∂ŒπŒΩŒ¨Œ¥ŒπŒ∫Œø"', 'Search: "hospital evaggelismos"', 'Search: "ŒõŒ±œäŒ∫œå ŒùŒøœÉŒøŒ∫ŒøŒºŒµŒØŒø"',
      'Search: "airport"', 'Search: "Œ±ŒµœÅŒøŒ¥œÅœåŒºŒπŒø"', 'Search: "port"', 'Search: "ŒªŒπŒºŒ¨ŒΩŒπ"',
      'Search: "ikea"', 'Search: "public store"', 'Search: "cosmote"', 'Search: "vodafone"',
      'Search: "restaurant"', 'Search: "taverna"', 'Search: "bakery"', 'Search: "œÜŒøœçœÅŒΩŒøœÇ"',
      'Search: "hair salon"', 'Search: "barber"', 'Search: "cinema"', 'Search: "Œ∏Œ≠Œ±œÑœÅŒø"'
    ];
    qEl.placeholder = PLACEHOLDERS[Math.floor(Math.random()*PLACEHOLDERS.length)];

    // =========================
    // Map
    // =========================
    const map = L.map("map", { maxBounds: ATHENS_BOUNDS, maxBoundsViscosity: 0.65 }).fitBounds(ATHENS_BOUNDS);
    map.setMinZoom(map.getZoom() - 2);

    // Canvas renderer helps perf with many markers
    const canvasRenderer = L.canvas({ padding: 0.5 });

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

    const markersLayer = L.layerGroup().addTo(map);
    const savedLayer = L.layerGroup().addTo(map);

    let routeLine = null;
    let destMarker = null;

    // Live tracking markers
    let myDot = null;
    let myArrow = null;

    // =========================
    // State
    // =========================
    let collapsed = false;
    let results = [];
    let selectedIndex = -1;

    let myLocation = null; // {lat, lon, lastLat, lastLon, lastUpdate, bearingDeg}
    let trackingOn = false;
    let followOn = false;
    let watchId = null;

    let nav = {
      mode: "walking",
      dest: null,
      steps: [],
      stepIndex: 0,
      distanceM: null,
      durationS: null,
      voiceOn: false
    };

    // Saved places
    const SAVED_KEY = "cpya_saved_places_v12";
    const RECENT_KEY = "cpya_recent_searches_v12";
    const UI_KEY = "cpya_ui_state_v12";
    const LAST_RESULTS_KEY = "cpya_last_results_v12";

    const SAVED_SLOTS = [
      { key:"home", label:"Home", icon:"üè†" },
      { key:"school", label:"School", icon:"üéì" },
      { key:"work", label:"Work", icon:"üíº" },
      { key:"custom", label:"Custom", icon:"‚≠ê" }
    ];

    let armSaveKey = null; // when set -> next map click saves this slot

    // =========================
    // Utils
    // =========================
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[m]));
    }

    function setLoading(on, text="Working‚Ä¶"){
      loadingText.textContent = text;
      loadingOverlay.style.display = on ? "flex" : "none";
    }

    function toast(title, msg, type="info", ms=3200){
      const el = document.createElement("div");
      el.className = `toast ${type}`;
      el.innerHTML = `
        <div>
          <div class="tTitle">${escapeHtml(title)}</div>
          <div class="tMsg">${escapeHtml(msg)}</div>
        </div>
        <div class="x">‚úï</div>
      `;
      el.querySelector(".x").addEventListener("click", () => el.remove());
      toastWrap.appendChild(el);
      setTimeout(() => { if (el.isConnected) el.remove(); }, ms);
    }

    function setStatus(s){ statusEl.textContent = s; }

    function formatDistanceMeters(m){
      if (!Number.isFinite(m)) return "‚Äî";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(1)} km`;
    }

    function formatDuration(s){
      if (!Number.isFinite(s)) return "‚Äî";
      const min = Math.round(s/60);
      if (min < 60) return `${min} min`;
      const h = Math.floor(min/60);
      const rem = min % 60;
      return `${h} h ${rem} min`;
    }

    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (x) => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    function bearingDeg(lat1, lon1, lat2, lon2){
      const toRad = (x) => x * Math.PI / 180;
      const toDeg = (x) => x * 180 / Math.PI;
      const œÜ1 = toRad(lat1), œÜ2 = toRad(lat2);
      const ŒîŒª = toRad(lon2 - lon1);
      const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
      const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
      const Œ∏ = Math.atan2(y, x);
      return (toDeg(Œ∏) + 360) % 360;
    }

    function estimateDurationSeconds(distanceM, mode){
      const walkingMps = 4.8 * 1000 / 3600;
      const drivingMps = 25  * 1000 / 3600;
      const mps = (mode === "driving") ? drivingMps : walkingMps;
      return distanceM / mps;
    }

    // =========================
    // Offline hint + app-shell caching via Service Worker
    // =========================
    function updateOfflineHint(){
      if (navigator.onLine){
        offlineHint.textContent = "";
      } else {
        offlineHint.textContent = "Offline: showing saved places & last results only. New searches/routes need internet.";
      }
    }
    window.addEventListener("online", updateOfflineHint);
    window.addEventListener("offline", updateOfflineHint);

    // Register service worker (creates a very basic offline shell)
    // Note: we create SW dynamically, so you don't need another file.
    async function registerSW(){
      if (!("serviceWorker" in navigator)) return;
      try{
        const swCode = `
          const CACHE = "cpya-athens-v12";
          self.addEventListener("install", (e) => {
            e.waitUntil((async()=>{
              const c = await caches.open(CACHE);
              // cache the app shell (this HTML only - served as /)
              // It will be cached on first visit.
              await self.skipWaiting();
            })());
          });
          self.addEventListener("activate", (e) => {
            e.waitUntil(self.clients.claim());
          });
          self.addEventListener("fetch", (e) => {
            const req = e.request;
            // Only GET
            if (req.method !== "GET") return;
            e.respondWith((async()=>{
              const cache = await caches.open(CACHE);
              const cached = await cache.match(req);
              if (cached) return cached;

              try{
                const res = await fetch(req);
                // Cache same-origin assets (our app responses)
                const url = new URL(req.url);
                if (url.origin === location.origin){
                  cache.put(req, res.clone());
                }
                return res;
              } catch(err){
                // If offline and no cache:
                // try return cached "/" as fallback for navigation
                const url = new URL(req.url);
                if (url.origin === location.origin){
                  const fallback = await cache.match(location.origin + "/");
                  if (fallback) return fallback;
                }
                throw err;
              }
            })());
          });
        `;
        const blob = new Blob([swCode], { type: "text/javascript" });
        const swUrl = URL.createObjectURL(blob);
        await navigator.serviceWorker.register(swUrl);
      } catch {}
    }

    // =========================
    // Saved places storage + map icons
    // =========================
    function loadJson(key, fallback){
      try{ const v = JSON.parse(localStorage.getItem(key) || ""); return v ?? fallback; } catch { return fallback; }
    }
    function saveJson(key, value){
      localStorage.setItem(key, JSON.stringify(value));
    }

    function loadSaved(){
      const o = loadJson(SAVED_KEY, {});
      return (o && typeof o === "object") ? o : {};
    }
    function saveSaved(o){
      saveJson(SAVED_KEY, o);
      renderChips();
      renderSavedMarkers();
    }

    function setSavedPlace(key, lat, lon){
      const saved = loadSaved();
      saved[key] = { lat, lon, updatedAt: Date.now() };
      saveSaved(saved);
    }
    function clearSavedPlace(key){
      const saved = loadSaved();
      delete saved[key];
      saveSaved(saved);
    }

    function renderSavedMarkers(){
      savedLayer.clearLayers();
      const saved = loadSaved();

      SAVED_SLOTS.forEach(slot=>{
        const p = saved[slot.key];
        if (!p || !Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return;

        const icon = L.divIcon({
          className: "",
          html: `<div style="display:flex;align-items:center;justify-content:center;width:34px;height:34px;border-radius:999px;border:1px solid rgba(255,255,255,.18);background:rgba(17,19,24,.92);box-shadow:${getComputedStyle(document.documentElement).getPropertyValue('--shadow')};font-size:18px">${slot.icon}</div>`,
          iconSize: [34,34],
          iconAnchor: [17,17]
        });

        const m = L.marker([p.lat, p.lon], { icon }).addTo(savedLayer);
        m.bindTooltip(`${slot.icon} ${slot.label}`, { direction:"top", offset:[0,-10], opacity:0.95 });

        m.on("click", ()=>{
          setDestination({ lat:p.lat, lon:p.lon, name: slot.label, address:"" });
        });
      });
    }

    // =========================
    // Recents
    // =========================
    function loadRecent(){
      const arr = loadJson(RECENT_KEY, []);
      return Array.isArray(arr) ? arr : [];
    }
    function saveRecent(q){
      const cur = loadRecent().filter(x => String(x).toLowerCase() !== String(q).toLowerCase());
      cur.unshift(q);
      saveJson(RECENT_KEY, cur.slice(0, 8));
      renderChips();
    }

    function renderChips(){
      const rec = loadRecent();
      const saved = loadSaved();

      const parts = [];
      SAVED_SLOTS.forEach(slot=>{
        const has = !!saved[slot.key];
        parts.push(`<span class="pill" data-saved="${slot.key}">${slot.icon} ${has ? slot.label : ("Set " + slot.label)}</span>`);
      });
      parts.push(`<span class="pill" data-more="1">More ‚ñæ</span>`);

      rec.slice(0,6).forEach((s,i) => parts.push(`<span class="pill" data-recent="${i}">${escapeHtml(s)}</span>`));
      chipsEl.innerHTML = parts.join("");

      chipsEl.querySelectorAll("[data-recent]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const idx = Number(el.getAttribute("data-recent"));
          const q = rec[idx];
          qEl.value = q;
          doSearch(q);
        });
      });

      chipsEl.querySelectorAll("[data-saved]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const key = el.getAttribute("data-saved");
          const saved = loadSaved();
          const p = saved[key];

          if (p){
            // go
            setDestination({ lat:p.lat, lon:p.lon, name:key, address:"" });
            return;
          }

          // arm map click (or use selected destination immediately)
          armSaveKey = key;
          if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
            setSavedPlace(key, nav.dest.lat, nav.dest.lon);
            toast("Saved", `${key} saved from selected destination.`, "ok");
            armSaveKey = null;
            return;
          }
          toast("Set place", `Tap the map to set ${key}.`, "info", 5200);
        });
      });

      chipsEl.querySelector("[data-more]")?.addEventListener("click", ()=>{
        const msg =
          `To change a saved place:\n`+
          `1) Tap its pill (Home/School/Work/Custom)\n`+
          `2) Tap the map where you want it.\n\n`+
          `To clear: open DevTools ‚Üí Application ‚Üí LocalStorage.\n`+
          `We can add a real ‚ÄúClear‚Äù menu next.`;
        toast("Saved places", msg, "info", 7000);
      });
    }

    // =========================
    // Voice (less creepy + prefer female-ish)
    // =========================
    let cachedVoices = [];
    function refreshVoices(){
      cachedVoices = (window.speechSynthesis && speechSynthesis.getVoices) ? speechSynthesis.getVoices() : [];
    }
    if ("speechSynthesis" in window){
      refreshVoices();
      speechSynthesis.onvoiceschanged = refreshVoices;
    }

    function pickVoicePreferFemale(){
      if (!cachedVoices.length) refreshVoices();

      // Greek voices first
      const greek = cachedVoices.filter(v => (v.lang || "").toLowerCase().startsWith("el"));

      // Heuristics: names that often correspond to female voices
      const femaleHints = ["female", "woman", "maria", "eleni", "anna", "zira", "siri", "karen", "google", "helena"];
      const pickFrom = (arr) => {
        for (const hint of femaleHints){
          const found = arr.find(v => (v.name || "").toLowerCase().includes(hint));
          if (found) return found;
        }
        // otherwise pick default
        return arr[0] || null;
      };

      const greekPick = pickFrom(greek);
      if (greekPick) return greekPick;

      // fallback english
      const english = cachedVoices.filter(v => (v.lang || "").toLowerCase().startsWith("en"));
      return pickFrom(english) || cachedVoices[0] || null;
    }

    function speak(text){
      try{
        const style = voiceStyleSel.value;
        if (style === "off") return;
        if (!("speechSynthesis" in window)) return;

        const voice = pickVoicePreferFemale();
        const u = new SpeechSynthesisUtterance(String(text));

        if (voice){
          u.voice = voice;
          u.lang = voice.lang || "en-US";
        }

        // soften it
        if (style === "soft"){
          u.rate = 1.02;
          u.pitch = 1.15;
          u.volume = 0.95;
        } else {
          u.rate = 1.05;
          u.pitch = 1.05;
          u.volume = 1.0;
        }

        window.speechSynthesis.cancel();
        window.speechSynthesis.speak(u);
      } catch {}
    }

    // =========================
    // Weather (same as before)
    // =========================
    function weatherIcon(code) {
      code = Number(code);
      if (code === 0) return "‚òÄÔ∏è";
      if (code <= 2) return "‚õÖ";
      if (code === 3) return "‚òÅÔ∏è";
      if ((code >= 51 && code <= 57) || (code >= 61 && code <= 67) || (code >= 80 && code <= 82)) return "üåßÔ∏è";
      if ((code >= 71 && code <= 77) || code === 85 || code === 86) return "‚ùÑÔ∏è";
      if (code === 45 || code === 48) return "üå´Ô∏è";
      if (code >= 95) return "‚õàÔ∏è";
      return "üå¶Ô∏è";
    }

    async function updateWeather(lat, lon){
      weatherCard.style.display = "block";
      weatherCard.innerHTML = `
        <div style="font-weight:900">Weather</div>
        <div class="line">Loading‚Ä¶</div>
      `;
      try{
        const r = await fetch(`/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`);
        const d = await r.json();
        if (!d?.ok || !d?.data?.current) throw new Error("weather unavailable");
        const c = d.data.current;
        const icon = weatherIcon(c.weather_code);

        weatherCard.innerHTML = `
          <div style="display:flex;align-items:center;gap:8px;">
            <div style="font-weight:900">Weather</div>
            <div style="opacity:.9">${icon}</div>
          </div>
          <div class="big">${Math.round(c.temperature_2m)}¬∞C <span class="small">(feels ${Math.round(c.apparent_temperature)}¬∞C)</span></div>
          <div class="line">Wind ${Math.round(c.wind_speed_10m)} km/h</div>
          <div class="tiny">${escapeHtml(String(c.time||"").replace("T"," "))}</div>
        `;
      } catch {
        weatherCard.innerHTML = `
          <div style="font-weight:900">Weather</div>
          <div class="line" style="color:rgba(255,77,77,.9)">Unavailable</div>
        `;
      }
    }

    // =========================
    // Routing + maneuver icons
    // =========================
    function maneuverIcon(step){
      const m = step.maneuver || {};
      const type = (m.type || "").toLowerCase();
      const mod = (m.modifier || "").toLowerCase();

      // modifier icons
      if (type === "arrive") return "üèÅ";
      if (type === "depart") return "üö©";
      if (type === "roundabout") return "üîÑ";
      if (type === "uturn") return "‚Ü©Ô∏è";
      if (mod.includes("left")) return "‚¨ÖÔ∏è";
      if (mod.includes("right")) return "‚û°Ô∏è";
      if (mod.includes("straight")) return "‚¨ÜÔ∏è";
      if (type === "merge") return "‚§¥Ô∏è";
      if (type === "fork") return "üç¥";
      if (type === "continue") return "‚¨ÜÔ∏è";
      return "‚û°Ô∏è";
    }

    function buildInstruction(step){
      const m = step.maneuver || {};
      const type = (m.type || "").toLowerCase();
      const mod  = (m.modifier || "").toLowerCase();
      const name = step.name ? ` onto ${step.name}` : "";

      if (type === "depart") return `Start${name}`;
      if (type === "arrive") return `Arrive at destination`;
      if (type === "roundabout") return `At roundabout, take exit${name}`;
      if (type === "merge") return `Merge${name}`;
      if (type === "on ramp") return `Take the ramp${name}`;
      if (type === "off ramp") return `Exit the ramp${name}`;
      if (type === "uturn") return `Make a U-turn${name}`;

      if (type === "turn"){
        if (mod) return `Turn ${mod}${name}`;
        return `Turn${name}`;
      }

      if (type === "continue" || type === "new name" || type === "straight"){
        return `Continue${name}`;
      }

      if (type === "fork"){
        if (mod) return `Keep ${mod}${name}`;
        return `Keep${name}`;
      }

      return step.name ? `Go on ${step.name}` : "Continue";
    }

    async function startRoute(){
      if (!myLocation || !nav.dest) return;

      nav.mode = modeSel.value || "walking";
      setStatus("Calculating route‚Ä¶");
      navCard.style.display = "block";
      navInstr.textContent = "Calculating route‚Ä¶";
      navSub.textContent = "‚Äî";

      try{
        const url =
          `https://router.project-osrm.org/route/v1/${nav.mode}/` +
          `${myLocation.lon},${myLocation.lat};${nav.dest.lon},${nav.dest.lat}` +
          `?overview=full&geometries=geojson&steps=true`;

        const r = await fetch(url);
        const j = await r.json();
        const route = j.routes?.[0];
        if (!route) throw new Error("no route");

        const coords = route.geometry?.coordinates || [];
        const latlngs = coords.map(c => [c[1], c[0]]);
        if (routeLine) routeLine.remove();
        routeLine = L.polyline(latlngs).addTo(map);

        const leg = route.legs?.[0];
        const steps = Array.isArray(leg?.steps) ? leg.steps : [];
        nav.steps = steps.map(s => ({
          distance: s.distance,
          duration: s.duration,
          name: s.name || "",
          maneuver: s.maneuver || {},
          instruction: buildInstruction(s)
        }));

        nav.stepIndex = 0;
        nav.distanceM = route.distance;
        nav.durationS = estimateDurationSeconds(nav.distanceM, nav.mode);

        setStatus(`Route: ${formatDistanceMeters(nav.distanceM)} ‚Ä¢ ~${formatDuration(nav.durationS)} (${nav.mode})`);
        showNavStep();
        cacheUiState();
      } catch {
        setStatus("Route failed.");
        toast("Route error", "Could not calculate route. Try again.", "bad");
        nav.steps = [];
        navCard.style.display = "none";
      }
    }

    function showNavStep(){
      if (!nav.steps.length) return;

      const i = Math.min(Math.max(nav.stepIndex, 0), nav.steps.length - 1);
      nav.stepIndex = i;

      const s = nav.steps[i];
      const icon = maneuverIcon(s);
      navInstr.textContent = `${icon} ${s.instruction}`;

      navSub.textContent =
        `Step ${i+1}/${nav.steps.length} ¬∑ ${formatDistanceMeters(s.distance)} ¬∑ Total ${formatDistanceMeters(nav.distanceM)} ¬∑ ~${formatDuration(nav.durationS)} (${nav.mode})`;

      navPrev.disabled = (i === 0);
      navNext.disabled = (i === nav.steps.length - 1);

      if (voiceStyleSel.value !== "off") speak(`${s.instruction}`);

      // follow maneuver point if follow mode ON
      if (followOn){
        const loc = s.maneuver?.location;
        if (Array.isArray(loc) && loc.length === 2){
          map.panTo([loc[1], loc[0]], { animate:true });
        }
      }
    }

    function stopNav(){
      nav.steps = [];
      nav.stepIndex = 0;
      nav.distanceM = null;
      nav.durationS = null;
      navCard.style.display = "none";
    }

    // =========================
    // Destination + markers (with tooltip so pins are not silent)
    // =========================
    function setDestination(x){
      if (!x) return;

      let dest = { ...x };
      if (!inAthens(dest.lat, dest.lon)){
        const c = clampToAthens(dest.lat, dest.lon);
        dest.lat = c.lat; dest.lon = c.lon;
        toast("Outside Athens", "Clamped inside Athens bounds.", "info");
      }

      nav.dest = dest;

      if (destMarker) destMarker.remove();
      destMarker = L.marker([dest.lat, dest.lon]).addTo(map);
      destMarker.bindTooltip(dest.name || "Destination", { direction:"top", offset:[0,-10], opacity:0.95 });
      destMarker.bindPopup(`<b>${escapeHtml(dest.name||"Destination")}</b>`).openPopup();

      map.setView([dest.lat, dest.lon], Math.max(map.getZoom(), 15));
      updateWeather(dest.lat, dest.lon);

      if (myLocation) startRoute();

      cacheUiState();
    }

    // =========================
    // Results rendering (NAME only; address optional)
    // =========================
    function normalizeAddress(name, address){
      if (!address) return "";
      const n = String(name||"").trim().toLowerCase();
      const a = String(address||"").trim();

      // if address basically repeats name at start, drop it
      if (a.trim().toLowerCase().startsWith(n) && n.length > 3) return "";
      // trim huge strings
      if (a.length > 80) return a.slice(0, 80) + "‚Ä¶";
      return a;
    }

    function renderResults(){
      if (!results.length){
        resultsWrap.style.display = "none";
        clearBtn.style.display = "none";
        return;
      }

      resultsWrap.style.display = "block";
      clearBtn.style.display = "inline-flex";
      resultsMeta.textContent = `${results.length} found`;

      resultsList.innerHTML = results.map((x,i)=>{
        const addr = normalizeAddress(x.name, x.address);
        return `
          <div class="res ${i===selectedIndex ? "selected":""}" data-idx="${i}">
            <div class="resTitle">${escapeHtml(x.name || "Place")}</div>
            ${addr ? `<div class="resMeta">${escapeHtml(addr)}</div>` : ``}
          </div>
        `;
      }).join("");

      resultsList.querySelectorAll("[data-idx]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const i = Number(el.getAttribute("data-idx"));
          pickResult(i);
        });
      });
    }

    function renderMarkers(){
      markersLayer.clearLayers();
      const bounds = [];

      // cap marker count for performance
      const MAX_MARKERS = 120;
      const list = results.slice(0, MAX_MARKERS);

      list.forEach((x,i)=>{
        bounds.push([x.lat, x.lon]);

        const m = L.marker([x.lat, x.lon]).addTo(markersLayer);
        m.bindTooltip(x.name || "Place", { direction:"top", offset:[0,-10], opacity:0.95 });

        m.on("click", ()=> pickResult(i));
      });

      if (bounds.length){
        map.fitBounds(bounds, { padding:[30,30] });
      }

      if (results.length > MAX_MARKERS){
        toast("Many results", `Showing first ${MAX_MARKERS} markers for performance.`, "info", 4500);
      }
    }

    function pickResult(i){
      const x = results[i];
      if (!x) return;
      selectedIndex = i;
      renderResults();
      setDestination(x);
    }

    // =========================
    // Suggestions (debounced)
    // =========================
    let suggestTimer = null;

    async function fetchSuggestions(q){
      if (!q || q.length < 2) { suggestBox.style.display="none"; return; }
      try{
        const r = await fetch("/where", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ q })
        });
        const d = await r.json();
        const list = Array.isArray(d?.results) ? d.results.slice(0,6) : [];
        const inBox = list
          .map(x => ({ name:x.name, address:x.address, lat:Number(x.lat), lon:Number(x.lon) }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
          .filter(x => inAthens(x.lat, x.lon))
          .slice(0,6);

        if (!inBox.length) { suggestBox.style.display="none"; return; }

        suggestBox.innerHTML = inBox.map((x,i)=>`
          <div class="item" data-sug="${i}">
            <div><b>${escapeHtml(x.name || "Place")}</b></div>
            <div class="sub">${escapeHtml(normalizeAddress(x.name, x.address) || "")}</div>
          </div>
        `).join("");
        suggestBox.style.display="block";

        suggestBox.querySelectorAll("[data-sug]").forEach(el=>{
          el.addEventListener("click", ()=>{
            const idx = Number(el.getAttribute("data-sug"));
            const pick = inBox[idx];
            suggestBox.style.display="none";
            qEl.value = pick.name || q;
            setDestination(pick);
          });
        });
      } catch {
        suggestBox.style.display="none";
      }
    }

    function scheduleSuggest(){
      clearTimeout(suggestTimer);
      const q = qEl.value.trim();
      suggestTimer = setTimeout(()=>fetchSuggestions(q), 220);
    }

    function hideSuggest(){ suggestBox.style.display="none"; }

    // =========================
    // Search + Nearby
    // =========================
    function showSearchSkeleton(){
      resultsWrap.style.display = "block";
      clearBtn.style.display = "inline-flex";
      resultsMeta.textContent = "Searching‚Ä¶";
      resultsList.innerHTML = `<div class="res"><div class="resTitle">Searching‚Ä¶</div><div class="resMeta">Please wait</div></div>`;
    }

    async function doSearch(qOverride=null){
      const q = (qOverride ?? qEl.value).trim();
      if (!q) return;

      hideSuggest();
      saveRecent(q);

      setLoading(true, "Searching‚Ä¶");
      setStatus("Searching‚Ä¶");
      showSearchSkeleton();

      try{
        const r = await fetch("/where", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ q })
        });
        const d = await r.json();

        const list = Array.isArray(d?.results) ? d.results : [];
        const filtered = list
          .map(x => ({
            name: x.name,
            address: x.address,
            lat: Number(x.lat),
            lon: Number(x.lon),
          }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
          .filter(x => inAthens(x.lat, x.lon));

        results = filtered;
        selectedIndex = results.length ? 0 : -1;

        // save last results for offline view
        saveJson(LAST_RESULTS_KEY, results.slice(0,200));

        if (!results.length){
          setStatus("No results.");
          toast("No results", "Try a different search.", "info");
          resultsWrap.style.display = "none";
          clearBtn.style.display = "none";
          markersLayer.clearLayers();
          setLoading(false);
          return;
        }

        setStatus(`Found ${results.length} results.`);
        renderMarkers();
        renderResults();
        pickResult(0);
      } catch {
        setStatus("Network error.");
        toast("Network error", "Could not reach the server. Try again.", "bad");
      } finally {
        setLoading(false);
      }

      cacheUiState();
    }

    async function nearMe(){
      if (!myLocation){
        toast("Need location", "Enable Live tracking first.", "bad");
        return;
      }

      hideSuggest();
      setLoading(true, "Searching near you‚Ä¶");
      setStatus("Searching near you‚Ä¶");
      showSearchSkeleton();

      try{
        const cat = nearSel.value;
        const r = await fetch(`/nearby?lat=${encodeURIComponent(myLocation.lat)}&lon=${encodeURIComponent(myLocation.lon)}&cat=${encodeURIComponent(cat)}`);
        const d = await r.json();

        const list = Array.isArray(d?.results) ? d.results : [];

        // allow a lot, but keep a cap for marker render
        const filtered = list
          .map(x => ({ name:x.name, address:x.address, lat:Number(x.lat), lon:Number(x.lon) }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
          .filter(x => inAthens(x.lat, x.lon));

        results = filtered;
        selectedIndex = results.length ? 0 : -1;

        saveJson(LAST_RESULTS_KEY, results.slice(0,200));

        if (!results.length){
          setStatus("Nothing found near you.");
          toast("No nearby results", "Try a different category.", "info");
          resultsWrap.style.display = "none";
          clearBtn.style.display = "none";
          markersLayer.clearLayers();
          setLoading(false);
          return;
        }

        setStatus(`Found ${results.length} nearby.`);
        renderMarkers();
        renderResults();
        pickResult(0);
      } catch {
        setStatus("Network error.");
        toast("Network error", "Could not fetch nearby places.", "bad");
      } finally {
        setLoading(false);
      }

      cacheUiState();
    }

    // =========================
    // Live tracking (watchPosition) + arrow marker
    // =========================
    function arrowIcon(deg){
      return L.divIcon({
        className:"",
        html: `
          <div style="
            width:34px;height:34px;border-radius:999px;
            border:1px solid rgba(255,255,255,.18);
            background:rgba(17,19,24,.92);
            display:flex;align-items:center;justify-content:center;
            box-shadow:${getComputedStyle(document.documentElement).getPropertyValue('--shadow')};
          ">
            <div style="transform: rotate(${deg}deg); font-size:18px;">‚û§</div>
          </div>
        `,
        iconSize:[34,34],
        iconAnchor:[17,17]
      });
    }

    function setMyMarkers(lat, lon, bearing){
      if (!myDot){
        myDot = L.circleMarker([lat, lon], { radius: 7, renderer: canvasRenderer }).addTo(map);
        myDot.bindTooltip("You", { direction:"top", offset:[0,-10], opacity:0.95 });
      } else {
        myDot.setLatLng([lat, lon]);
      }

      const b = Number.isFinite(bearing) ? bearing : 0;

      if (!myArrow){
        myArrow = L.marker([lat, lon], { icon: arrowIcon(b) }).addTo(map);
      } else {
        myArrow.setLatLng([lat, lon]);
        myArrow.setIcon(arrowIcon(b));
      }
    }

    function startTracking(){
      if (!navigator.geolocation){
        toast("Unsupported", "Your browser does not support location.", "bad");
        return;
      }
      if (trackingOn) return;

      trackingOn = true;
      locBtn.textContent = "Live tracking: On";
      toast("Tracking", "Live tracking enabled.", "ok");

      watchId = navigator.geolocation.watchPosition(
        (pos) => {
          const rawLat = pos.coords.latitude;
          const rawLon = pos.coords.longitude;

          const outside = !inAthens(rawLat, rawLon);
          const use = outside ? clampToAthens(rawLat, rawLon) : { lat: rawLat, lon: rawLon };

          const now = Date.now();
          let bearing = myLocation?.bearingDeg ?? 0;

          if (myLocation && Number.isFinite(myLocation.lat) && Number.isFinite(myLocation.lon)){
            const moved = haversineMeters(myLocation.lat, myLocation.lon, use.lat, use.lon);
            if (moved > 3){ // update bearing only if moved
              bearing = bearingDeg(myLocation.lat, myLocation.lon, use.lat, use.lon);
            }
          }

          myLocation = { lat: use.lat, lon: use.lon, bearingDeg: bearing, lastUpdate: now };
          setMyMarkers(use.lat, use.lon, bearing);

          if (outside){
            // don‚Äôt spam toast every update; only once
          }

          if (followOn){
            map.panTo([use.lat, use.lon], { animate:true });
          }

          // If navigating, reroute occasionally if moved far
          if (nav.dest){
            const distToDest = haversineMeters(use.lat, use.lon, nav.dest.lat, nav.dest.lon);
            // simple reroute heuristic
            if (!myLocation._lastRerouteAt) myLocation._lastRerouteAt = 0;
            if (Date.now() - myLocation._lastRerouteAt > 12000){
              myLocation._lastRerouteAt = Date.now();
              startRoute();
            }
          }
        },
        (err) => {
          toast("Location error", err?.message || "Could not get location.", "bad", 5200);
          stopTracking();
        },
        { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
      );
    }

    function stopTracking(){
      trackingOn = false;
      locBtn.textContent = "Live tracking: Off";
      if (watchId != null){
        navigator.geolocation.clearWatch(watchId);
        watchId = null;
      }
      toast("Tracking", "Live tracking disabled.", "info");
    }

    // =========================
    // Map click behavior:
    // - if armSaveKey => save
    // - else => set destination
    // =========================
    map.on("click", (e) => {
      const { lat, lng } = e.latlng;

      if (armSaveKey){
        setSavedPlace(armSaveKey, lat, lng);
        toast("Saved", `${armSaveKey} saved from map click.`, "ok");
        armSaveKey = null;
        return;
      }

      setDestination({ lat, lon: lng, name: "Pinned location", address: "" });
      toast("Pinned", "Destination pinned. Calculating route‚Ä¶", "info");
    });

    // =========================
    // Clear
    // =========================
    function clearAll(){
      results = [];
      selectedIndex = -1;
      markersLayer.clearLayers();
      if (routeLine) { routeLine.remove(); routeLine = null; }
      if (destMarker) { destMarker.remove(); destMarker = null; }
      nav.dest = null;
      stopNav();
      resultsWrap.style.display = "none";
      clearBtn.style.display = "none";
      resultsList.innerHTML = "";
      resultsMeta.textContent = "‚Äî";
      setStatus("Ready");
      cacheUiState();
    }

    // =========================
    // Panel collapse
    // =========================
    function setCollapsed(state){
      collapsed = !!state;
      panelBody.style.display = collapsed ? "none" : "block";
      togglePanelBtn.textContent = collapsed ? "‚ñ∏" : "‚ñæ";
      setTimeout(()=>map.invalidateSize(), 50);
    }

    // =========================
    // Cache UI + restore + offline last results
    // =========================
    function cacheUiState(){
      try{
        const state = {
          q: qEl.value || "",
          mode: modeSel.value || "walking",
          voiceStyle: voiceStyleSel.value || "off",
          lastDest: nav.dest ? { lat: nav.dest.lat, lon: nav.dest.lon, name: nav.dest.name, address: nav.dest.address } : null,
          selectedIndex
        };
        saveJson(UI_KEY, state);
      } catch {}
    }

    function restoreUiState(){
      const state = loadJson(UI_KEY, null);
      if (state){
        if (state.q) qEl.value = state.q;
        if (state.mode) modeSel.value = state.mode;
        if (state.voiceStyle) voiceStyleSel.value = state.voiceStyle;
        if (state.lastDest && Number.isFinite(state.lastDest.lat) && Number.isFinite(state.lastDest.lon)){
          nav.dest = { ...state.lastDest };
          updateWeather(nav.dest.lat, nav.dest.lon);
        }
      }

      // If offline, show last results so app still "works"
      if (!navigator.onLine){
        const last = loadJson(LAST_RESULTS_KEY, []);
        if (Array.isArray(last) && last.length){
          results = last.slice(0,120);
          selectedIndex = 0;
          renderMarkers();
          renderResults();
          toast("Offline results", "Loaded last results from cache.", "info", 5000);
        }
      }
    }

    // =========================
    // Wiring buttons
    // =========================
    btn.addEventListener("click", ()=>doSearch());
    qEl.addEventListener("keydown", (e)=>{
      if (e.key === "Enter") doSearch();
      else scheduleSuggest();
    });
    qEl.addEventListener("input", scheduleSuggest);
    qEl.addEventListener("blur", ()=> setTimeout(hideSuggest, 140));

    nearBtn.addEventListener("click", nearMe);

    locBtn.addEventListener("click", ()=>{
      if (!trackingOn) startTracking();
      else stopTracking();
      cacheUiState();
    });

    modeSel.addEventListener("change", ()=>{
      if (myLocation && nav.dest) startRoute();
      cacheUiState();
    });

    voiceStyleSel.addEventListener("change", ()=>{
      cacheUiState();
      toast("Voice", `Set to: ${voiceStyleSel.value}`, "info", 2200);
    });

    clearBtn.addEventListener("click", ()=>{
      clearAll();
      toast("Cleared", "Results and route cleared.", "info");
    });

    togglePanelBtn.addEventListener("click", ()=> setCollapsed(!collapsed));

    navPrev.addEventListener("click", ()=>{ nav.stepIndex = Math.max(0, nav.stepIndex - 1); showNavStep(); });
    navNext.addEventListener("click", ()=>{ nav.stepIndex = Math.min(nav.steps.length - 1, nav.stepIndex + 1); showNavStep(); });
    navClose.addEventListener("click", ()=>{ stopNav(); toast("Navigation ended", "Route panel closed.", "info"); });

    navFollowBtn.addEventListener("click", ()=>{
      followOn = !followOn;
      navFollowBtn.textContent = followOn ? "üß≠ Follow: On" : "üß≠ Follow: Off";
      toast("Follow", followOn ? "Map will follow you." : "Follow disabled.", "info");
    });

    navCenter.addEventListener("click", ()=>{
      if (myLocation){
        map.setView([myLocation.lat, myLocation.lon], Math.max(map.getZoom(), 15));
      } else if (nav.dest){
        map.setView([nav.dest.lat, nav.dest.lon], Math.max(map.getZoom(), 15));
      } else {
        map.fitBounds(ATHENS_BOUNDS, { padding:[20,20] });
      }
    });

    // =========================
    // Init
    // =========================
    window.addEventListener("DOMContentLoaded", async ()=>{
      await registerSW();
      updateOfflineHint();
      renderChips();
      renderSavedMarkers();
      restoreUiState();
    });
  </script>
</body>
</html>
