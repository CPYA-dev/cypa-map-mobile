<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>Athens Navigator</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#07080b;
      --card: rgba(17,19,24,.92);
      --text:#e8eaed;
      --muted:#aab0bb;
      --line:rgba(255,255,255,.10);
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 22px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
      --accent:#4aa3ff;
      --danger:#ff4d4d;
      --ok:#00d084;
    }

    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background:var(--bg); color:var(--text); }
    #app { height: 100%; position:relative; }
    #map { height: 100%; width: 100%; }

    .card{
      background: var(--card);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    /* Splash */
    #splash{
      position: fixed; inset: 0; z-index: 9000;
      display:flex; align-items:center; justify-content:center;
      background: #07080b;
      transition: opacity .35s ease;
    }
    #splash.hidden{ opacity:0; pointer-events:none; }
    #splashInner{ width: min(420px, 86vw); text-align:center; }
    #splashLogo{
      width: 100%;
      border-radius: 18px;
      box-shadow: var(--shadow);
      border: 1px solid rgba(255,255,255,.10);
      background: linear-gradient(135deg, rgba(74,163,255,.22), rgba(255,255,255,.06));
      padding: 22px 16px;
    }
    #splashLogo h1{ margin:0; font-size: 22px; letter-spacing:.2px; }
    #splashLogo p{ margin:8px 0 0; color: var(--muted); font-size: 13px; }
    #splashMeta{ margin-top: 14px; color: var(--muted); font-size: 12px; line-height: 1.5; }
    #splashMeta b{ color: var(--text); }

    /* Toasts */
    #toastWrap{
      position: fixed;
      top: calc(12px + var(--safe-top));
      left: 50%;
      transform: translateX(-50%);
      z-index: 6500;
      display:flex;
      flex-direction:column;
      gap:8px;
      width: min(520px, 92vw);
      pointer-events:none;
    }
    .toast{
      pointer-events:auto;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(17,19,24,.92);
      box-shadow: var(--shadow);
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .toast .tTitle{ font-size: 13px; font-weight: 900; margin-bottom: 2px; }
    .toast .tMsg{ font-size: 13px; color: var(--muted); white-space:pre-line; }
    .toast .x{ margin-left:auto; cursor:pointer; opacity:.8; user-select:none; }
    .toast.info{ border-color: rgba(74,163,255,.35); }
    .toast.bad{ border-color: rgba(255,77,77,.35); }
    .toast.ok{ border-color: rgba(0,208,132,.35); }

    /* Loading overlay */
    #loadingOverlay{ position: fixed; inset: 0; display:none; align-items:center; justify-content:center; z-index: 5000; background: rgba(0,0,0,.35); backdrop-filter: blur(3px); }
    .loaderCard{ padding: 14px 16px; border-radius: 18px; border: 1px solid var(--line); background: rgba(17,19,24,.92); box-shadow: var(--shadow); display:flex; align-items:center; gap:12px; max-width: 92vw; }
    .spinner{ width: 18px; height: 18px; border: 2px solid rgba(255,255,255,.2); border-top-color: rgba(255,255,255,.9); border-radius: 999px; animation: spin 0.9s linear infinite; }
    @keyframes spin { to { transform: rotate(360deg); } }

    /* Top HUD (time / weather / compass) */
    #topHud{
      position: fixed;
      left: 12px;
      right: 12px;
      top: calc(10px + var(--safe-top));
      z-index: 3000;
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      pointer-events:none; /* only children should be clickable */
    }
    .hudGroup{ display:flex; gap:10px; align-items:center; pointer-events:auto; }
    .hudPill{
      display:flex; align-items:center; gap:10px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(17,19,24,.82);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      user-select:none;
    }
    .hudIcon{
      width: 34px; height: 34px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:center;
      font-size: 16px;
    }
    .hudText{ display:flex; flex-direction:column; line-height: 1.05; }
    .hudText .a{ font-weight: 950; font-size: 13px; }
    .hudText .b{ font-size: 11px; color: var(--muted); margin-top: 2px; }
    .hudBtn{
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(17,19,24,.82);
      color: var(--text);
      border-radius: 999px;
      padding: 10px 12px;
      cursor:pointer;
      user-select:none;
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      display:flex; align-items:center; gap:8px;
    }
    .hudBtn:hover{ background: rgba(255,255,255,.10); }
    #compassNeedle{
      width: 18px; height: 18px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.18);
      background: rgba(255,255,255,.06);
      display:flex; align-items:center; justify-content:center;
      font-size: 12px;
      transform: rotate(0deg);
      transition: transform .10s linear;
    }

    /* Buttons / inputs */
    .btn{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn.primary{ background: rgba(74,163,255,.18); border-color: rgba(74,163,255,.35); }
    .btn.danger{ background: rgba(255,77,77,.14); border-color: rgba(255,77,77,.35); }
    .btn.slim{ padding: 10px 10px; font-size: 14px; border-radius: 12px; }
    .btn.icon{ width: 44px; height: 44px; border-radius: 14px; display:flex; align-items:center; justify-content:center; padding: 0; }

    .input{
      flex: 1 1 auto;
      min-width: 0;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 16px;
      outline:none;
    }
    select{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 14px;
    }
    .small { font-size: 12px; color: var(--muted); }
    .row{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; }
    .row.nowrap{ flex-wrap:nowrap; }
    .spacer{ flex: 1; }

    /* Suggestions */
    #suggestBox{
      position: fixed;
      left: 12px; right: 12px;
      top: calc(72px + var(--safe-top));
      display:none;
      z-index: 3200;
      border-radius: 16px;
      overflow:hidden;
      max-width: 760px;
      margin: 0 auto;
    }
    #suggestBox .item{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
      background: rgba(17,19,24,.96);
    }
    #suggestBox .item:last-child{ border-bottom:none; }
    #suggestBox .item:hover{ background: rgba(255,255,255,.06); }
    #suggestBox .sub{ font-size:12px; color: var(--muted); margin-top:3px; }

    /* Bottom Sheet (panel) */
    #panel{
      z-index: 2600;
      position: fixed;
      left: 0; right: 0;
      bottom: 0;
      background: rgba(8,10,14,.92);
      border-top: 1px solid var(--line);
      border-top-left-radius: var(--radius2);
      border-top-right-radius: var(--radius2);
      padding: 10px 12px calc(10px + var(--safe-bottom));
      transform: translateY(0);
      transition: transform .22s ease;
      will-change: transform;
    }
    #panelHandle{
      width: 44px; height: 5px;
      border-radius: 999px;
      background: rgba(255,255,255,.22);
      margin: 4px auto 10px;
      cursor: grab; user-select:none;
    }

    /* Tabs */
    #tabs{
      display:flex;
      gap:8px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      padding: 6px;
      overflow:auto;
      -webkit-overflow-scrolling: touch;
    }
    .tab{
      flex: 0 0 auto;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid transparent;
      cursor:pointer;
      user-select:none;
      color: var(--muted);
      background: transparent;
      font-weight: 850;
      font-size: 13px;
      display:flex; align-items:center; gap:8px;
      white-space:nowrap;
    }
    .tab.active{
      color: var(--text);
      background: rgba(74,163,255,.16);
      border-color: rgba(74,163,255,.35);
    }

    /* Category rail */
    #catRail{
      display:flex;
      gap:10px;
      overflow:auto;
      padding: 4px 2px;
      -webkit-overflow-scrolling: touch;
    }
    .cat{
      flex: 0 0 auto;
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
      font-weight: 850;
      font-size: 13px;
    }
    .cat:hover{ background: rgba(255,255,255,.08); }
    .cat.active{ background: rgba(74,163,255,.16); border-color: rgba(74,163,255,.35); }

    /* Results */
    #resultsWrap{ margin-top: 10px; display:none; }
    #resultsHeader{ display:flex; justify-content:space-between; align-items:center; gap:10px; margin-bottom: 8px; }
    #resultsList{
      max-height: 240px;
      overflow:auto;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .res{ padding: 10px 12px; border-bottom: 1px solid rgba(255,255,255,.06); cursor:pointer; }
    .res:last-child{ border-bottom:none; }
    .res:hover{ background: rgba(255,255,255,.06); }
    .res.selected{ background: rgba(74,163,255,.16); outline: 1px solid rgba(74,163,255,.35); }
    .resTitle{ font-size: 14px; font-weight: 900; }
    .resMeta{ font-size: 12px; color: var(--muted); margin-top: 3px; }

    /* Mini actions strip */
    #miniActions{
      display:flex;
      gap:8px;
      flex-wrap:wrap;
      align-items:center;
      margin-top: 10px;
    }
    .chipBtn{
      display:inline-flex;
      align-items:center;
      gap:8px;
      padding: 10px 12px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.05);
      cursor:pointer;
      user-select:none;
      font-weight: 850;
      font-size: 13px;
    }
    .chipBtn:hover{ background: rgba(255,255,255,.09); }

    /* Nav card (top) */
    #navCard{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      top: calc(72px + var(--safe-top));
      z-index: 2400;
      padding: 12px 12px;
      border-radius: 18px;
      display:none;
      width: min(760px, 92vw);
      pointer-events:auto;
    }
    #navTop{ display:flex; align-items:center; justify-content:space-between; gap:10px; margin-bottom: 8px; }
    #navInstr{ font-size: 16px; font-weight: 950; line-height: 1.15; }
    #navSub{ font-size: 12px; color: var(--muted); margin-top: 3px; }
    #navBtns{ display:flex; gap:8px; align-items:center; flex-wrap:wrap; margin-top: 10px; }

    /* Zoom pill (always centered above panel) */
    #zoomPill{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(var(--panel-clear, 190px) + var(--safe-bottom));
      z-index: 2400;
      display:flex;
      overflow:hidden;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(17,19,24,.88);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
      pointer-events:auto;
    }
    .zoomBtn{
      padding: 10px 14px;
      cursor:pointer;
      user-select:none;
      border: none;
      background: transparent;
      color: var(--text);
      font-size: 18px;
    }
    .zoomBtn:hover{ background: rgba(255,255,255,.08); }
    .zoomSep{ width: 1px; background: rgba(255,255,255,.12); }

    /* Floating restore button (when panel closed) */
    #panelRestore{
      position: fixed;
      right: 12px;
      bottom: calc(12px + var(--safe-bottom));
      z-index: 4000;
      width: 52px;
      height: 52px;
      border-radius: 18px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(17,19,24,.92);
      color: var(--text);
      box-shadow: var(--shadow);
      cursor:pointer;
      display:none;
      align-items:center;
      justify-content:center;
      font-size: 18px;
      backdrop-filter: blur(10px);
    }
    #panelRestore.show{ display:flex; }

    /* Modal */
    #modal{
      position: fixed; inset: 0; z-index: 8000;
      display:none; align-items:center; justify-content:center;
      background: rgba(0,0,0,.45);
      backdrop-filter: blur(3px);
      padding: 14px;
    }
    #modalCard{
      width: min(720px, 96vw);
      max-height: min(78vh, 740px);
      overflow:auto;
      padding: 14px;
      border-radius: 18px;
    }
    .mTitle{ font-weight: 900; font-size: 16px; margin-bottom: 10px; }
    .mRow{ display:flex; gap:10px; align-items:center; flex-wrap:wrap; margin-top: 10px; }
    .mItem{
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid rgba(255,255,255,.10);
      background: rgba(255,255,255,.04);
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-top: 10px;
    }
    .mItem b{ font-weight:900; }
    .mItem .meta{ color: var(--muted); font-size: 12px; margin-top: 2px; }
    .mBtns{ display:flex; gap:8px; flex-wrap:wrap; justify-content:flex-end; }
    .mInput{
      width: 100%;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid rgba(255,255,255,.12);
      border-radius: 12px;
      padding: 10px 10px;
      outline:none;
    }

    /* Desktop: right drawer style */
    @media (min-width: 900px){
      #panel{
        top: calc(12px + var(--safe-top));
        bottom: auto;
        left: auto;
        right: 12px;
        width: 420px;
        border: 1px solid var(--line);
        border-radius: var(--radius2);
        padding: 12px;
        transform: translateX(0);
      }
      #panelHandle{
        width: 46px; height: 34px;
        margin: 0 0 10px auto;
        display:flex; align-items:center; justify-content:center;
        background: rgba(255,255,255,.06);
        border: 1px solid rgba(255,255,255,.10);
        border-radius: 14px;
        cursor:pointer;
      }
      #panelRestore{
        right: 12px;
        bottom: calc(12px + var(--safe-bottom));
      }
      #suggestBox{
        top: calc(62px + var(--safe-top));
        max-width: 820px;
      }
      #navCard{
        top: calc(12px + var(--safe-top));
      }
    }

    /* Leaflet: hide default zoom controls (we use pill) */
    .leaflet-control-zoom{ display:none !important; }
  </style>
</head>

<body>
  <div id="splash">
    <div id="splashInner">
      <div id="splashLogo">
        <h1>Athens Navigator</h1>
        <p>Search ‚Ä¢ Explore ‚Ä¢ Navigate</p>
      </div>
      <div id="splashMeta">
        <div><b>Athens Navigator</b> ¬∑ v1.2</div>
        <div>¬© 2025 Athens Navigator. All rights reserved.</div>
      </div>
    </div>
  </div>

  <div id="toastWrap"></div>

  <div id="loadingOverlay">
    <div class="loaderCard">
      <div class="spinner"></div>
      <div>
        <div style="font-weight:900">Working‚Ä¶</div>
        <div style="font-size:13px;color:var(--muted)" id="loadingText">Loading</div>
      </div>
    </div>
  </div>

  <!-- Top HUD -->
  <div id="topHud">
    <div class="hudGroup">
      <div class="hudPill" id="timePill" title="Local time">
        <div class="hudIcon">üïí</div>
        <div class="hudText">
          <div class="a" id="timeMain">‚Äî</div>
          <div class="b" id="timeSub">‚Äî</div>
        </div>
      </div>

      <div class="hudPill" id="weatherPill" title="Weather at destination / your location">
        <div class="hudIcon" id="weatherIcon">‚õÖ</div>
        <div class="hudText">
          <div class="a" id="weatherMain">Weather</div>
          <div class="b" id="weatherSub">‚Äî</div>
        </div>
      </div>

      <div class="hudPill" id="compassPill" title="Compass">
        <div class="hudIcon"><div id="compassNeedle">‚ñ≤</div></div>
        <div class="hudText">
          <div class="a" id="compassMain">N</div>
          <div class="b" id="compassSub">‚Äî</div>
        </div>
      </div>
    </div>

    <div class="hudGroup">
      <button class="hudBtn" id="settingsBtn" type="button" title="Settings">
        ‚öôÔ∏è <span style="font-weight:900;font-size:13px;">Settings</span>
      </button>
    </div>
  </div>

  <!-- Suggestions dropdown -->
  <div id="suggestBox" class="card"></div>

  <!-- Nav card -->
  <div id="navCard" class="card">
    <div id="navTop">
      <div style="min-width:0">
        <div id="navInstr">‚Äî</div>
        <div id="navSub">‚Äî</div>
      </div>
      <div style="display:flex;gap:8px;align-items:center;">
        <button class="btn slim" id="navPrev" title="Previous step">‚óÄ</button>
        <button class="btn slim primary" id="navNext" title="Next step">‚ñ∂</button>
        <button class="btn slim" id="navClose" title="End navigation">‚úï</button>
      </div>
    </div>
    <div id="navBtns">
      <button class="btn slim" id="navVoice">üîà Voice: Off</button>
      <button class="btn slim" id="navFollow">üß≠ Follow: On</button>
      <button class="btn slim primary" id="navMe">üìç Me</button>
    </div>
  </div>

  <!-- Zoom -->
  <div id="zoomPill" aria-label="Zoom">
    <button class="zoomBtn" id="zoomOut" title="Zoom out">‚àí</button>
    <div class="zoomSep"></div>
    <button class="zoomBtn" id="zoomIn" title="Zoom in">+</button>
  </div>

  <!-- Restore panel button -->
  <button id="panelRestore" type="button" aria-label="Open menu">‚ò∞</button>

  <!-- Modal -->
  <div id="modal">
    <div id="modalCard" class="card">
      <div class="mRow" style="justify-content:space-between;">
        <div class="mTitle" id="modalTitle">‚Äî</div>
        <button class="btn slim" id="modalClose">‚úï</button>
      </div>
      <div id="modalBody"></div>
    </div>
  </div>

  <div id="app">
    <div id="map"></div>

    <!-- Bottom sheet -->
    <div id="panel" class="card">
      <div id="panelHandle" title="Drag up/down">‚ãÆ‚ãÆ</div>

      <div id="tabs">
        <div class="tab active" data-tab="search">üîé Search</div>
        <div class="tab" data-tab="explore">‚ú® Explore</div>
        <div class="tab" data-tab="saved">‚≠ê Saved</div>
        <div class="tab" data-tab="settings">‚öôÔ∏è Settings</div>
      </div>

      <!-- SEARCH TAB -->
      <div id="tab_search" style="margin-top:10px;">
        <div class="row nowrap">
          <input id="q" class="input" placeholder="Search‚Ä¶" autocomplete="off" />
          <button id="micBtn" class="btn icon" type="button" title="Speech search">üéôÔ∏è</button>
          <button id="btn" class="btn primary" type="button">Find</button>
        </div>

        <div class="row" style="margin-top:10px;">
          <button id="myLocBtn" class="btn" type="button">My location</button>
          <select id="modeSel">
            <option value="walking">üö∂ Walking</option>
            <option value="driving">üöó Driving</option>
          </select>
          <button id="trackBtn" class="btn" type="button">Live tracking: On</button>
          <button id="clearBtn" class="btn danger" type="button" style="display:none;">Clear</button>
          <span class="small" id="status">Ready</span>
        </div>

        <div id="resultsWrap">
          <div id="resultsHeader">
            <div style="font-weight:900">Results</div>
            <div class="small" id="resultsMeta">‚Äî</div>
          </div>
          <div id="resultsList"></div>
        </div>

        <div id="offlineHint" class="small" style="margin-top:10px; opacity:.9"></div>
      </div>

      <!-- EXPLORE TAB -->
      <div id="tab_explore" style="margin-top:10px; display:none;">
        <div class="small" style="opacity:.95">
          Explore places around the map center (tap a category).
        </div>

        <div id="catRail" style="margin-top:10px;"></div>

        <div class="row" style="margin-top:10px;">
          <button id="exploreRefresh" class="btn slim" type="button">‚Üª Refresh at center</button>
          <div class="spacer"></div>
          <div class="small" id="exploreMeta">‚Äî</div>
        </div>

        <div id="exploreWrap" style="margin-top:10px; display:none;">
          <div id="exploreList" style="
            max-height: 240px; overflow:auto;
            border-radius: 14px;
            border: 1px solid var(--line);
            background: rgba(255,255,255,.04);
          "></div>
        </div>
      </div>

      <!-- SAVED TAB -->
      <div id="tab_saved" style="margin-top:10px; display:none;">
        <div class="small" style="opacity:.95">
          Manage saved places (Home / School / Work + custom).
        </div>

        <div id="miniActions">
          <div class="chipBtn" id="savedManageBtn">‚≠ê Open saved places</div>
          <div class="chipBtn" id="saveHomeBtn">üè† Set Home</div>
          <div class="chipBtn" id="saveSchoolBtn">üéì Set School</div>
          <div class="chipBtn" id="saveWorkBtn">üíº Set Work</div>
          <div class="chipBtn" id="addPlaceBtn">‚ûï Add place</div>
        </div>

        <div class="small" style="margin-top:10px; opacity:.9">
          Tip: select a destination first to save instantly, or tap ‚ÄúSet ‚Ä¶‚Äù then tap the map.
        </div>
      </div>

      <!-- SETTINGS TAB (placeholder) -->
      <div id="tab_settings" style="margin-top:10px; display:none;">
        <div class="small" style="opacity:.95">
          Settings coming soon.
        </div>

        <div class="mItem" style="margin-top:12px;">
          <div>
            <b>Voice</b>
            <div class="meta">We‚Äôll add a proper voice selector here later.</div>
          </div>
          <button class="btn slim" type="button" id="voiceTestBtn">Test</button>
        </div>

        <div class="mItem">
          <div>
            <b>UI</b>
            <div class="meta">Theme / density / advanced map options.</div>
          </div>
          <button class="btn slim" type="button" disabled>‚Äî</button>
        </div>

        <div class="mItem">
          <div>
            <b>About</b>
            <div class="meta" id="aboutLine">‚Äî</div>
          </div>
          <button class="btn slim" type="button" id="resetUiBtn">Reset UI</button>
        </div>
      </div>
    </div>
  </div>

  <script>
  const APP_VERSION = "1.2";

  // Athens bounds (looser so you can reach Piraeus etc.)
  const ATHENS_BBOX = { west: 23.35, south: 37.70, east: 24.35, north: 38.30 };
  const ATHENS_BOUNDS = L.latLngBounds([ATHENS_BBOX.south, ATHENS_BBOX.west],[ATHENS_BBOX.north, ATHENS_BBOX.east]);

  function inAthens(lat, lon) {
    return lon >= ATHENS_BBOX.west && lon <= ATHENS_BBOX.east &&
           lat >= ATHENS_BBOX.south && lat <= ATHENS_BBOX.north;
  }
  function clampToAthens(lat, lon){
    return {
      lat: Math.min(Math.max(lat, ATHENS_BBOX.south), ATHENS_BBOX.north),
      lon: Math.min(Math.max(lon, ATHENS_BBOX.west), ATHENS_BBOX.east)
    };
  }

  // DOM
  const splash = document.getElementById("splash");
  const qEl = document.getElementById("q");
  const btn = document.getElementById("btn");
  const micBtn = document.getElementById("micBtn");
  const myLocBtn = document.getElementById("myLocBtn");
  const modeSel = document.getElementById("modeSel");
  const trackBtn = document.getElementById("trackBtn");
  const statusEl = document.getElementById("status");
  const resultsWrap = document.getElementById("resultsWrap");
  const resultsList = document.getElementById("resultsList");
  const resultsMeta = document.getElementById("resultsMeta");
  const clearBtn = document.getElementById("clearBtn");
  const suggestBox = document.getElementById("suggestBox");
  const loadingOverlay = document.getElementById("loadingOverlay");
  const loadingText = document.getElementById("loadingText");
  const toastWrap = document.getElementById("toastWrap");

  const topHud = document.getElementById("topHud");
  const timeMain = document.getElementById("timeMain");
  const timeSub  = document.getElementById("timeSub");
  const weatherIconEl = document.getElementById("weatherIcon");
  const weatherMain = document.getElementById("weatherMain");
  const weatherSub  = document.getElementById("weatherSub");
  const compassNeedle = document.getElementById("compassNeedle");
  const compassMain = document.getElementById("compassMain");
  const compassSub  = document.getElementById("compassSub");
  const settingsBtn = document.getElementById("settingsBtn");

  const navCard = document.getElementById("navCard");
  const navInstr = document.getElementById("navInstr");
  const navSub = document.getElementById("navSub");
  const navPrev = document.getElementById("navPrev");
  const navNext = document.getElementById("navNext");
  const navClose = document.getElementById("navClose");
  const navVoice = document.getElementById("navVoice");
  const navFollowBtn = document.getElementById("navFollow");
  const navMe = document.getElementById("navMe");

  const zoomInBtn = document.getElementById("zoomIn");
  const zoomOutBtn = document.getElementById("zoomOut");

  const panel = document.getElementById("panel");
  const panelHandle = document.getElementById("panelHandle");
  const panelRestore = document.getElementById("panelRestore");
  const offlineHint = document.getElementById("offlineHint");

  const modal = document.getElementById("modal");
  const modalClose = document.getElementById("modalClose");
  const modalTitle = document.getElementById("modalTitle");
  const modalBody = document.getElementById("modalBody");

  const tabs = Array.from(document.querySelectorAll(".tab"));
  const tab_search = document.getElementById("tab_search");
  const tab_explore = document.getElementById("tab_explore");
  const tab_saved = document.getElementById("tab_saved");
  const tab_settings = document.getElementById("tab_settings");

  const catRail = document.getElementById("catRail");
  const exploreRefresh = document.getElementById("exploreRefresh");
  const exploreMeta = document.getElementById("exploreMeta");
  const exploreWrap = document.getElementById("exploreWrap");
  const exploreList = document.getElementById("exploreList");

  const savedManageBtn = document.getElementById("savedManageBtn");
  const saveHomeBtn = document.getElementById("saveHomeBtn");
  const saveSchoolBtn = document.getElementById("saveSchoolBtn");
  const saveWorkBtn = document.getElementById("saveWorkBtn");
  const addPlaceBtn = document.getElementById("addPlaceBtn");

  const voiceTestBtn = document.getElementById("voiceTestBtn");
  const resetUiBtn = document.getElementById("resetUiBtn");
  const aboutLine = document.getElementById("aboutLine");

  // Storage keys
  const SAVED_KEY = "athnav_saved_v12";
  const RECENT_KEY = "athnav_recent_v12";
  const UI_KEY = "athnav_ui_v12";
  const LAST_RESULTS_KEY = "athnav_last_results_v12";

  // State
  let results = [];
  let selectedIndex = -1;

  let myLocation = null; // {lat, lon, bearingDeg, lastUpdate, lastRerouteAt}
  let trackingOn = true;
  let followOn = true;
  let watchId = null;

  let nav = {
    mode: "walking",
    dest: null,
    steps: [],
    stepIndex: 0,
    distanceM: null,
    durationS: null,
    voiceStyle: "off" // off | soft
  };

  let armSave = null; // {type:"fixed", key} | {type:"custom", name}
  let panelOpen = true;

  // Utils
  function escapeHtml(s) {
    return String(s).replace(/[&<>"']/g, m => ({
      "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
    }[m]));
  }

  let loadingShownAt = 0;
  const MIN_LOADING_MS = 800;
  function setLoading(on, text="Working‚Ä¶") {
    loadingText.textContent = text;
    if (on) {
      loadingShownAt = Date.now();
      loadingOverlay.style.display = "flex";
      return;
    }
    const elapsed = Date.now() - loadingShownAt;
    const wait = Math.max(0, MIN_LOADING_MS - elapsed);
    setTimeout(() => { loadingOverlay.style.display = "none"; }, wait);
  }

  function toast(title, msg, type="info", ms=3200) {
    const el = document.createElement("div");
    el.className = `toast ${type}`;
    el.innerHTML = `
      <div>
        <div class="tTitle">${escapeHtml(title)}</div>
        <div class="tMsg">${escapeHtml(msg)}</div>
      </div>
      <div class="x">‚úï</div>
    `;
    el.querySelector(".x").addEventListener("click", () => el.remove());
    toastWrap.appendChild(el);
    setTimeout(() => { if (el.isConnected) el.remove(); }, ms);
  }

  function setStatus(s){ statusEl.textContent = s; }

  function loadJson(key, fallback) {
    try { const v = JSON.parse(localStorage.getItem(key) || ""); return (v ?? fallback); }
    catch { return fallback; }
  }
  function saveJson(key, value) { localStorage.setItem(key, JSON.stringify(value)); }

  function uid(){
    return Math.random().toString(16).slice(2) + Date.now().toString(16);
  }

  function haversineMeters(lat1, lon1, lat2, lon2) {
    const R = 6371000;
    const toRad = (x) => x * Math.PI / 180;
    const dLat = toRad(lat2 - lat1);
    const dLon = toRad(lon2 - lon1);
    const a =
      Math.sin(dLat / 2) ** 2 +
      Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
    const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
    return R * c;
  }

  function bearingDeg(lat1, lon1, lat2, lon2){
    const toRad = (x) => x * Math.PI / 180;
    const toDeg = (x) => x * 180 / Math.PI;
    const œÜ1 = toRad(lat1), œÜ2 = toRad(lat2);
    const ŒîŒª = toRad(lon2 - lon1);
    const y = Math.sin(ŒîŒª) * Math.cos(œÜ2);
    const x = Math.cos(œÜ1)*Math.sin(œÜ2) - Math.sin(œÜ1)*Math.cos(œÜ2)*Math.cos(ŒîŒª);
    const Œ∏ = Math.atan2(y, x);
    return (toDeg(Œ∏) + 360) % 360;
  }

  function formatDistanceMeters(m){
    if (!Number.isFinite(m)) return "‚Äî";
    if (m < 1000) return `${Math.round(m)} m`;
    return `${(m/1000).toFixed(1)} km`;
  }
  function formatDuration(s){
    if (!Number.isFinite(s)) return "‚Äî";
    const min = Math.round(s/60);
    if (min < 60) return `${min} min`;
    const h = Math.floor(min/60);
    const rem = min % 60;
    return `${h} h ${rem} min`;
  }

  function estimateDurationSeconds(distanceM, mode){
    const walkingMps = 4.8 * 1000 / 3600;
    const drivingMps = 22  * 1000 / 3600;
    const mps = (mode === "driving") ? drivingMps : walkingMps;
    return distanceM / mps;
  }

  function normalizeAddress(name, address){
    if (!address) return "";
    const n = String(name||"").trim().toLowerCase();
    const a = String(address||"").trim();
    if (n && a.toLowerCase().startsWith(n) && n.length > 3) return "";
    if (a.length > 80) return a.slice(0,80) + "‚Ä¶";
    return a;
  }

  // Top HUD: time
  function tickTime(){
    const d = new Date();
    const hh = String(d.getHours()).padStart(2,"0");
    const mm = String(d.getMinutes()).padStart(2,"0");
    timeMain.textContent = `${hh}:${mm}`;
    timeSub.textContent = d.toLocaleDateString(undefined, { weekday:"short", month:"short", day:"numeric" });
  }

  // Weather icon
  function weatherIcon(code) {
    code = Number(code);
    if (code === 0) return "‚òÄÔ∏è";
    if (code <= 2) return "‚õÖ";
    if (code === 3) return "‚òÅÔ∏è";
    if ((code >= 51 && code <= 57) || (code >= 61 && code <= 67) || (code >= 80 && code <= 82)) return "üåßÔ∏è";
    if ((code >= 71 && code <= 77) || code === 85 || code === 86) return "‚ùÑÔ∏è";
    if (code === 45 || code === 48) return "üå´Ô∏è";
    if (code >= 95) return "‚õàÔ∏è";
    return "üå¶Ô∏è";
  }

  // Weather: always show on HUD (dest > myLocation > map center)
  async function updateWeatherSmart(){
    const center = map.getCenter();
    let lat = center.lat, lon = center.lng;
    let label = "Map";

    if (nav?.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
      lat = nav.dest.lat; lon = nav.dest.lon; label = "Dest";
    } else if (myLocation && Number.isFinite(myLocation.lat) && Number.isFinite(myLocation.lon)){
      lat = myLocation.lat; lon = myLocation.lon; label = "Me";
    }

    weatherMain.textContent = "Weather";
    weatherSub.textContent = "Loading‚Ä¶";

    try{
      const r = await fetch(`/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`);
      const d = await r.json();
      if (!d?.ok || !d?.data?.current) throw new Error("weather unavailable");
      const c = d.data.current;
      const icon = weatherIcon(c.weather_code);
      weatherIconEl.textContent = icon;
      weatherMain.textContent = `${Math.round(c.temperature_2m)}¬∞C`;
      weatherSub.textContent = `${label} ‚Ä¢ feels ${Math.round(c.apparent_temperature)}¬∞C`;
    } catch {
      weatherIconEl.textContent = "‚õÖ";
      weatherMain.textContent = "Weather";
      weatherSub.textContent = "Unavailable";
    }
  }

  // Compass: device orientation (if available) else use my bearing
  let compassDeg = 0;
  function degToCardinal(deg){
    const dirs = ["N","NE","E","SE","S","SW","W","NW"];
    const idx = Math.round(((deg % 360) / 45)) % 8;
    return dirs[idx];
  }
  function setCompass(deg){
    if (!Number.isFinite(deg)) return;
    compassDeg = (deg + 360) % 360;
    compassNeedle.style.transform = `rotate(${compassDeg}deg)`;
    compassMain.textContent = degToCardinal(compassDeg);
    compassSub.textContent = `${Math.round(compassDeg)}¬∞`;
  }

  async function initCompass(){
    // iOS needs permission
    try{
      if (window.DeviceOrientationEvent && typeof DeviceOrientationEvent.requestPermission === "function"){
        compassSub.textContent = "Tap to enable";
        document.getElementById("compassPill").style.cursor = "pointer";
        document.getElementById("compassPill").addEventListener("click", async ()=>{
          try{
            const res = await DeviceOrientationEvent.requestPermission();
            if (res !== "granted") throw new Error("denied");
            toast("Compass", "Enabled.", "ok", 1600);
          } catch {
            toast("Compass", "Permission denied.", "bad", 2400);
          }
        }, { once:true });
      }
    } catch {}

    window.addEventListener("deviceorientationabsolute", (e)=>{
      // absolute heading if available
      const h = e.alpha;
      if (Number.isFinite(h)) setCompass(360 - h);
    });

    window.addEventListener("deviceorientation", (e)=>{
      // fallback
      const h = e.alpha;
      if (Number.isFinite(h)) setCompass(360 - h);
    });

    // fallback: use movement bearing
    setInterval(()=>{
      if (myLocation && Number.isFinite(myLocation.bearingDeg)){
        // only use if device orientation didn‚Äôt really change
        if (!("DeviceOrientationEvent" in window)) setCompass(myLocation.bearingDeg);
      }
    }, 1200);
  }

  // Offline hint
  function updateOfflineHint(){
    offlineHint.textContent = navigator.onLine
      ? ""
      : "Offline: saved places + last results only. New searches/routes need internet.";
  }
  window.addEventListener("online", updateOfflineHint);
  window.addEventListener("offline", updateOfflineHint);

  // Service Worker (app shell cache)
  async function registerSW(){
    if (!("serviceWorker" in navigator)) return;
    try{
      const swCode = `
        const CACHE = "athens-navigator-v12";
        self.addEventListener("install", (e) => e.waitUntil(self.skipWaiting()));
        self.addEventListener("activate", (e) => e.waitUntil(self.clients.claim()));
        self.addEventListener("fetch", (e) => {
          if (e.request.method !== "GET") return;
          e.respondWith((async()=>{
            const cache = await caches.open(CACHE);
            const cached = await cache.match(e.request);
            if (cached) return cached;
            try{
              const res = await fetch(e.request);
              const url = new URL(e.request.url);
              if (url.origin === location.origin) cache.put(e.request, res.clone());
              return res;
            } catch(err){
              const url = new URL(e.request.url);
              if (url.origin === location.origin){
                const fallback = await cache.match(location.origin + "/");
                if (fallback) return fallback;
              }
              throw err;
            }
          })());
        });
      `;
      const blob = new Blob([swCode], { type: "text/javascript" });
      const swUrl = URL.createObjectURL(blob);
      await navigator.serviceWorker.register(swUrl);
    } catch {}
  }

  // Saved places model
  function loadSaved(){
    const o = loadJson(SAVED_KEY, { home:null, school:null, work:null, custom:[] });
    if (!o.custom) o.custom = [];
    return o;
  }
  function saveSaved(o){
    if (!o.custom) o.custom = [];
    saveJson(SAVED_KEY, o);
    renderSavedMarkers();
  }
  function setFixedPlace(key, lat, lon){
    const saved = loadSaved();
    saved[key] = { lat, lon, updatedAt: Date.now() };
    saveSaved(saved);
  }
  function addCustomPlace(name, lat, lon){
    const saved = loadSaved();
    const clean = String(name||"Place").trim() || "Place";
    saved.custom.unshift({ id: uid(), name: clean, lat, lon, createdAt: Date.now() });
    if (saved.custom.length > 200) saved.custom = saved.custom.slice(0,200);
    saveSaved(saved);
  }
  function updateCustomName(id, newName){
    const saved = loadSaved();
    const item = saved.custom.find(x => x.id === id);
    if (item){
      item.name = String(newName||"").trim() || item.name;
      saveSaved(saved);
    }
  }
  function deleteCustom(id){
    const saved = loadSaved();
    saved.custom = saved.custom.filter(x => x.id !== id);
    saveSaved(saved);
  }

  // Map
  const map = L.map("map", {
    zoomControl: false,
    maxBounds: ATHENS_BOUNDS,
    maxBoundsViscosity: 0.65
  }).fitBounds(ATHENS_BOUNDS);

  map.setMinZoom(map.getZoom() - 2);

  const canvasRenderer = L.canvas({ padding: 0.5 });
  L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

  const markersLayer = L.layerGroup().addTo(map);
  const savedLayer = L.layerGroup().addTo(map);

  let routeLine = null;
  let destMarker = null;

  // Tracking markers
  let myDot = null;
  let myArrow = null;

  // Recents / placeholders
  const PLACEHOLDERS = [
    'Search: "lidl"', 'Search: "Œ£Œ∫ŒªŒ±Œ≤ŒµŒΩŒØœÑŒ∑œÇ"', 'Search: "pharmacy"', 'Search: "œÜŒ±œÅŒºŒ±Œ∫ŒµŒØŒø"',
    'Search: "ŒΩŒøœÉŒøŒ∫ŒøŒºŒµŒØŒø"', 'Search: "souvlaki"', 'Search: "Œ∫Œ±œÜŒ≠"', 'Search: "metro"',
    'Search: "monastiraki"', 'Search: "syntagma"', 'Search: "acropolis"', 'Search: "hotel"'
  ];
  qEl.placeholder = PLACEHOLDERS[Math.floor(Math.random()*PLACEHOLDERS.length)];

  // Icons for markers
  function roundIcon(html){
    return L.divIcon({
      className: "",
      html: `
        <div style="
          display:flex;align-items:center;justify-content:center;
          width:34px;height:34px;border-radius:999px;
          border:1px solid rgba(255,255,255,.18);
          background:rgba(17,19,24,.92);
          box-shadow: var(--shadow);
          font-size:16px;
        ">${html}</div>
      `,
      iconSize:[34,34],
      iconAnchor:[17,17]
    });
  }

  function renderSavedMarkers(){
    savedLayer.clearLayers();
    const saved = loadSaved();

    const fixed = [
      { key:"home", label:"Home", icon:"üè†" },
      { key:"school", label:"School", icon:"üéì" },
      { key:"work", label:"Work", icon:"üíº" },
    ];

    fixed.forEach(slot => {
      const p = saved[slot.key];
      if (!p || !Number.isFinite(p.lat) || !Number.isFinite(p.lon)) return;
      const m = L.marker([p.lat, p.lon], { icon: roundIcon(slot.icon) }).addTo(savedLayer);
      m.bindTooltip(`${slot.icon} ${slot.label}`, { direction:"top", offset:[0,-10], opacity:0.95 });
      m.on("click", ()=> setDestination({ lat:p.lat, lon:p.lon, name: slot.label, address:"" }));
    });

    (saved.custom || []).forEach(item => {
      if (!Number.isFinite(item.lat) || !Number.isFinite(item.lon)) return;
      const initial = (String(item.name||"‚òÖ").trim()[0] || "‚òÖ").toUpperCase();
      const m = L.marker([item.lat, item.lon], { icon: roundIcon(`<b style="font-size:14px">${escapeHtml(initial)}</b>`) }).addTo(savedLayer);
      m.bindTooltip(item.name, { direction:"top", offset:[0,-10], opacity:0.95 });
      m.on("click", ()=> setDestination({ lat:item.lat, lon:item.lon, name: item.name, address:"" }));
    });
  }

  // Results rendering
  function renderResults(){
    if (!results.length){
      resultsWrap.style.display = "none";
      clearBtn.style.display = "none";
      return;
    }

    resultsWrap.style.display = "block";
    clearBtn.style.display = "inline-flex";
    resultsMeta.textContent = `${results.length} found`;

    resultsList.innerHTML = results.map((x,i)=>{
      const addr = normalizeAddress(x.name, x.address);
      return `
        <div class="res ${i===selectedIndex ? "selected":""}" data-idx="${i}">
          <div class="resTitle">${escapeHtml(x.name || "Place")}</div>
          ${addr ? `<div class="resMeta">${escapeHtml(addr)}</div>` : ``}
        </div>
      `;
    }).join("");

    resultsList.querySelectorAll("[data-idx]").forEach(el => {
      el.addEventListener("click", ()=>{
        const i = Number(el.getAttribute("data-idx"));
        pickResult(i);
      });
    });
  }

  function renderMarkers(){
    markersLayer.clearLayers();
    const bounds = [];

    const MAX_MARKERS = 140;
    const list = results.slice(0, MAX_MARKERS);

    list.forEach((x,i)=>{
      bounds.push([x.lat, x.lon]);
      const m = L.marker([x.lat, x.lon]).addTo(markersLayer);
      m.bindTooltip(x.name || "Place", { direction:"top", offset:[0,-10], opacity:0.95 });
      m.on("click", ()=> pickResult(i));
    });

    if (bounds.length) map.fitBounds(bounds, { padding:[30,30] });

    if (results.length > MAX_MARKERS){
      toast("Many results", `Showing first ${MAX_MARKERS} markers for performance.`, "info", 4500);
    }
  }

  function pickResult(i){
    const x = results[i];
    if (!x) return;
    selectedIndex = i;
    renderResults();
    setDestination(x);
  }

  // Suggestions (debounced)
  let suggestTimer = null;
  async function fetchSuggestions(q){
    if (!q || q.length < 2) { suggestBox.style.display="none"; return; }
    try{
      const r = await fetch("/where", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ q })
      });
      const d = await r.json();
      const list = Array.isArray(d?.results) ? d.results.slice(0,6) : [];
      const inBox = list
        .map(x => ({ name:x.name, address:x.address, lat:Number(x.lat), lon:Number(x.lon) }))
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
        .filter(x => inAthens(x.lat, x.lon))
        .slice(0,6);

      if (!inBox.length) { suggestBox.style.display="none"; return; }

      suggestBox.innerHTML = inBox.map((x,i)=>`
        <div class="item" data-sug="${i}">
          <div><b>${escapeHtml(x.name || "Place")}</b></div>
          <div class="sub">${escapeHtml(normalizeAddress(x.name, x.address) || "")}</div>
        </div>
      `).join("");
      suggestBox.style.display="block";

      suggestBox.querySelectorAll("[data-sug]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const idx = Number(el.getAttribute("data-sug"));
          const pick = inBox[idx];
          suggestBox.style.display="none";
          qEl.value = pick.name || q;
          setDestination(pick);
        });
      });
    } catch {
      suggestBox.style.display="none";
    }
  }

  function scheduleSuggest(){
    clearTimeout(suggestTimer);
    const q = qEl.value.trim();
    suggestTimer = setTimeout(()=>fetchSuggestions(q), 220);
  }
  function hideSuggest(){ suggestBox.style.display="none"; }

  // Routing + nav steps
  function maneuverIcon(step){
    const m = step.maneuver || {};
    const type = (m.type || "").toLowerCase();
    const mod = (m.modifier || "").toLowerCase();
    if (type === "arrive") return "üèÅ";
    if (type === "depart") return "üö©";
    if (type === "roundabout") return "üîÑ";
    if (type === "uturn") return "‚Ü©Ô∏è";
    if (mod.includes("left")) return "‚¨ÖÔ∏è";
    if (mod.includes("right")) return "‚û°Ô∏è";
    if (mod.includes("straight")) return "‚¨ÜÔ∏è";
    if (type === "merge") return "‚§¥Ô∏è";
    if (type === "fork") return "üç¥";
    if (type === "continue") return "‚¨ÜÔ∏è";
    return "‚û°Ô∏è";
  }

  function buildInstruction(step){
    const m = step.maneuver || {};
    const type = (m.type || "").toLowerCase();
    const mod  = (m.modifier || "").toLowerCase();
    const name = step.name ? ` onto ${step.name}` : "";

    if (type === "depart") return `Start${name}`;
    if (type === "arrive") return `Arrive at destination`;
    if (type === "roundabout") return `At roundabout, take exit${name}`;
    if (type === "merge") return `Merge${name}`;
    if (type === "uturn") return `Make a U-turn${name}`;

    if (type === "turn") {
      if (mod) return `Turn ${mod}${name}`;
      return `Turn${name}`;
    }
    if (type === "continue" || type === "new name" || type === "straight") return `Continue${name}`;
    if (type === "fork") return mod ? `Keep ${mod}${name}` : `Keep${name}`;

    return step.name ? `Go on ${step.name}` : "Continue";
  }

  // Voice
  let cachedVoices = [];
  function refreshVoices(){
    cachedVoices = (window.speechSynthesis && speechSynthesis.getVoices) ? speechSynthesis.getVoices() : [];
  }
  if ("speechSynthesis" in window){
    refreshVoices();
    speechSynthesis.onvoiceschanged = refreshVoices;
  }

  function pickBestVoice(){
    if (!cachedVoices.length) refreshVoices();
    // Prefer Greek if available, otherwise prefer "natural"/"neural"
    const greek = cachedVoices.filter(v => (v.lang || "").toLowerCase().startsWith("el"));
    const preferNatural = (arr) => arr.find(v => /natural|neural/i.test(v.name || "")) || null;
    const pickFirst = (arr) => arr[0] || null;
    return preferNatural(greek) || pickFirst(greek) || preferNatural(cachedVoices) || pickFirst(cachedVoices) || null;
  }

  function speak(text){
    try{
      if (nav.voiceStyle === "off") return;
      if (!("speechSynthesis" in window)) return;

      const voice = pickBestVoice();
      const u = new SpeechSynthesisUtterance(String(text));

      if (voice){
        u.voice = voice;
        u.lang = voice.lang || "en-US";
      }

      // This can still sound robotic depending on the phone/browser voice.
      u.rate = 0.95;
      u.pitch = 1.02;
      u.volume = 0.92;

      window.speechSynthesis.cancel();
      window.speechSynthesis.speak(u);
    } catch {}
  }

  function updateVoiceBtn(){
    navVoice.textContent = nav.voiceStyle === "off" ? "üîà Voice: Off" : "üîà Voice: Soft";
  }

  async function startRoute(){
    if (!myLocation || !nav.dest) return;

    nav.mode = modeSel.value || "walking";
    setStatus("Calculating route‚Ä¶");
    navCard.style.display = "block";
    navInstr.textContent = "Calculating route‚Ä¶";
    navSub.textContent = "‚Äî";

    try{
      const url =
        `https://router.project-osrm.org/route/v1/${nav.mode}/` +
        `${myLocation.lon},${myLocation.lat};${nav.dest.lon},${nav.dest.lat}` +
        `?overview=full&geometries=geojson&steps=true`;

      const r = await fetch(url);
      const j = await r.json();
      const route = j.routes?.[0];
      if (!route) throw new Error("no route");

      const coords = route.geometry?.coordinates || [];
      const latlngs = coords.map(c => [c[1], c[0]]);
      if (routeLine) routeLine.remove();
      routeLine = L.polyline(latlngs).addTo(map);

      const leg = route.legs?.[0];
      const steps = Array.isArray(leg?.steps) ? leg.steps : [];
      nav.steps = steps.map(s => ({
        distance: s.distance,
        duration: s.duration,
        name: s.name || "",
        maneuver: s.maneuver || {},
        instruction: buildInstruction(s)
      }));

      nav.stepIndex = 0;
      nav.distanceM = route.distance;
      nav.durationS = estimateDurationSeconds(nav.distanceM, nav.mode);

      setStatus(`Route: ${formatDistanceMeters(nav.distanceM)} ‚Ä¢ ~${formatDuration(nav.durationS)} (${nav.mode})`);
      showNavStep();
      cacheUiState();
    } catch {
      setStatus("Route failed.");
      toast("Route error", "Could not calculate route. Try again.", "bad");
      nav.steps = [];
      navCard.style.display = "none";
    }
  }

  function showNavStep(){
    if (!nav.steps.length) return;

    const i = Math.min(Math.max(nav.stepIndex, 0), nav.steps.length - 1);
    nav.stepIndex = i;

    const s = nav.steps[i];
    const icon = maneuverIcon(s);
    navInstr.textContent = `${icon} ${s.instruction}`;

    navSub.textContent =
      `Step ${i+1}/${nav.steps.length} ¬∑ ${formatDistanceMeters(s.distance)} ¬∑ Total ${formatDistanceMeters(nav.distanceM)} ¬∑ ~${formatDuration(nav.durationS)} (${nav.mode})`;

    navPrev.disabled = (i === 0);
    navNext.disabled = (i === nav.steps.length - 1);

    if (nav.voiceStyle !== "off") speak(s.instruction);

    if (followOn){
      const loc = s.maneuver?.location;
      if (Array.isArray(loc) && loc.length === 2){
        map.panTo([loc[1], loc[0]], { animate:true });
      }
    }
  }

  function stopNav(){
    nav.steps = [];
    nav.stepIndex = 0;
    nav.distanceM = null;
    nav.durationS = null;
    navCard.style.display = "none";
  }

  // Destination marker
  function setDestination(x){
    if (!x) return;

    let dest = { ...x };
    if (!inAthens(dest.lat, dest.lon)){
      const c = clampToAthens(dest.lat, dest.lon);
      dest.lat = c.lat; dest.lon = c.lon;
      toast("Outside Athens", "Clamped inside Athens bounds.", "info");
    }

    nav.dest = dest;

    if (destMarker) destMarker.remove();
    destMarker = L.marker([dest.lat, dest.lon]).addTo(map);
    destMarker.bindTooltip(dest.name || "Destination", { direction:"top", offset:[0,-10], opacity:0.95 });
    destMarker.bindPopup(`<b>${escapeHtml(dest.name||"Destination")}</b>`).openPopup();

    map.setView([dest.lat, dest.lon], Math.max(map.getZoom(), 15));
    updateWeatherSmart();

    if (myLocation) startRoute();
    cacheUiState();
  }

  // Search
  async function doSearch(qOverride=null){
    const q = (qOverride ?? qEl.value).trim();
    if (!q) return;

    hideSuggest();
    setLoading(true, "Searching‚Ä¶");
    setStatus("Searching‚Ä¶");

    try{
      const r = await fetch("/where", {
        method:"POST",
        headers:{ "Content-Type":"application/json" },
        body: JSON.stringify({ q })
      });
      const d = await r.json();

      const list = Array.isArray(d?.results) ? d.results : [];
      const filtered = list
        .map(x => ({ name: x.name, address: x.address, lat: Number(x.lat), lon: Number(x.lon) }))
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
        .filter(x => inAthens(x.lat, x.lon));

      results = filtered;
      selectedIndex = results.length ? 0 : -1;

      saveJson(LAST_RESULTS_KEY, results.slice(0,200));

      if (!results.length){
        setStatus("No results.");
        toast("No results", "Try a different search.", "info");
        resultsWrap.style.display = "none";
        clearBtn.style.display = "none";
        markersLayer.clearLayers();
        setLoading(false);
        return;
      }

      setStatus(`Found ${results.length} results.`);
      renderMarkers();
      renderResults();
      pickResult(0);
    } catch {
      setStatus("Network error.");
      toast("Network error", "Could not reach the server. Try again.", "bad");
      const last = loadJson(LAST_RESULTS_KEY, []);
      if (Array.isArray(last) && last.length){
        results = last;
        selectedIndex = 0;
        renderMarkers();
        renderResults();
        toast("Offline fallback", "Showing your last saved results.", "info", 5200);
      }
    } finally {
      setLoading(false);
    }

    cacheUiState();
  }

  // Explore (recommendation-ish): nearby around map center by category
  const EXPLORE_CATS = [
    { key:"cafe", label:"‚òï Cafes" },
    { key:"food", label:"üçï Food" },
    { key:"restaurant", label:"üçΩÔ∏è Restaurants" },
    { key:"pharmacy", label:"üíä Pharmacy" },
    { key:"supermarket", label:"üõí Supermarkets" },
    { key:"hotel", label:"üè® Hotels" },
    { key:"monument", label:"üèõÔ∏è Monuments" },
    { key:"museum", label:"üñºÔ∏è Museums" },
    { key:"park", label:"üå≥ Parks" },
    { key:"atm", label:"üèß ATM" }
  ];

  let exploreCat = "cafe";
  let exploreItems = [];

  function renderCatRail(){
    catRail.innerHTML = EXPLORE_CATS.map(c => `
      <div class="cat ${c.key === exploreCat ? "active":""}" data-cat="${c.key}">
        ${escapeHtml(c.label)}
      </div>
    `).join("");

    catRail.querySelectorAll("[data-cat]").forEach(el=>{
      el.addEventListener("click", ()=>{
        exploreCat = el.getAttribute("data-cat");
        renderCatRail();
        exploreFetch();
      });
    });
  }

  async function exploreFetch(){
    const center = map.getCenter();
    const lat = center.lat;
    const lon = center.lng;

    exploreMeta.textContent = "Loading‚Ä¶";
    exploreWrap.style.display = "none";

    setLoading(true, "Exploring‚Ä¶");
    try{
      const r = await fetch(`/nearby?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}&cat=${encodeURIComponent(exploreCat)}`);
      const d = await r.json();

      const list = Array.isArray(d?.results) ? d.results : [];
      const filtered = list
        .map(x => ({ name:x.name, address:x.address, lat:Number(x.lat), lon:Number(x.lon) }))
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
        .filter(x => inAthens(x.lat, x.lon));

      exploreItems = filtered.slice(0, 40);

      if (!exploreItems.length){
        exploreMeta.textContent = "No results";
        exploreWrap.style.display = "none";
        toast("Explore", "Nothing found around the center for this category.", "info", 2600);
        return;
      }

      exploreMeta.textContent = `${exploreItems.length} found`;
      exploreWrap.style.display = "block";

      exploreList.innerHTML = exploreItems.map((x,i)=>{
        const addr = normalizeAddress(x.name, x.address);
        return `
          <div class="res" data-exp="${i}">
            <div class="resTitle">${escapeHtml(x.name || "Place")}</div>
            ${addr ? `<div class="resMeta">${escapeHtml(addr)}</div>` : ``}
          </div>
        `;
      }).join("");

      exploreList.querySelectorAll("[data-exp]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const idx = Number(el.getAttribute("data-exp"));
          const pick = exploreItems[idx];
          if (!pick) return;
          setDestination(pick);
          // also copy into results so it behaves consistent
          results = exploreItems.slice(0, 200);
          selectedIndex = idx;
          renderMarkers();
          renderResults();
          switchTab("search");
        });
      });

    } catch {
      exploreMeta.textContent = "Network error";
      toast("Explore", "Could not load explore results.", "bad", 2600);
    } finally {
      setLoading(false);
    }
  }

  // Live tracking + arrow
  function arrowIcon(deg){
    return L.divIcon({
      className:"",
      html: `
        <div style="
          width:34px;height:34px;border-radius:999px;
          border:1px solid rgba(255,255,255,.18);
          background:rgba(17,19,24,.92);
          display:flex;align-items:center;justify-content:center;
          box-shadow: var(--shadow);
        ">
          <div style="transform: rotate(${deg}deg); font-size:18px;">‚û§</div>
        </div>
      `,
      iconSize:[34,34],
      iconAnchor:[17,17]
    });
  }

  function setMyMarkers(lat, lon, bearing){
    if (!myDot){
      myDot = L.circleMarker([lat, lon], { radius: 7, renderer: canvasRenderer }).addTo(map);
      myDot.bindTooltip("You", { direction:"top", offset:[0,-10], opacity:0.95 });
    } else {
      myDot.setLatLng([lat, lon]);
    }

    const b = Number.isFinite(bearing) ? bearing : 0;

    if (!myArrow){
      myArrow = L.marker([lat, lon], { icon: arrowIcon(b) }).addTo(map);
    } else {
      myArrow.setLatLng([lat, lon]);
      myArrow.setIcon(arrowIcon(b));
    }
  }

  function setTrackingBtn(){
    trackBtn.textContent = trackingOn ? "Live tracking: On" : "Live tracking: Off";
  }

  function startTracking(){
    if (!navigator.geolocation){
      toast("Unsupported", "Your browser does not support location.", "bad");
      return;
    }
    if (watchId != null) return;

    watchId = navigator.geolocation.watchPosition(
      (pos) => {
        const rawLat = pos.coords.latitude;
        const rawLon = pos.coords.longitude;

        const outside = !inAthens(rawLat, rawLon);
        const use = outside ? clampToAthens(rawLat, rawLon) : { lat: rawLat, lon: rawLon };

        const now = Date.now();
        let b = myLocation?.bearingDeg ?? 0;

        if (myLocation && Number.isFinite(myLocation.lat) && Number.isFinite(myLocation.lon)){
          const moved = haversineMeters(myLocation.lat, myLocation.lon, use.lat, use.lon);
          if (moved > 3) b = bearingDeg(myLocation.lat, myLocation.lon, use.lat, use.lon);
        }

        myLocation = myLocation || {};
        myLocation.lat = use.lat;
        myLocation.lon = use.lon;
        myLocation.bearingDeg = b;
        myLocation.lastUpdate = now;
        myLocation.lastRerouteAt = myLocation.lastRerouteAt || 0;

        setMyMarkers(use.lat, use.lon, b);

        if (followOn) map.panTo([use.lat, use.lon], { animate:true });

        // keep HUD weather relevant
        // (throttle)
        if (nav.dest == null && (now % 15000) < 1200){
          updateWeatherSmart();
        }

        if (nav.dest && (Date.now() - myLocation.lastRerouteAt) > 12000){
          myLocation.lastRerouteAt = Date.now();
          startRoute();
        }
      },
      (err) => {
        toast("Location error", err?.message || "Could not get location.", "bad", 5200);
        stopTracking();
      },
      { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
    );
  }

  function stopTracking(){
    if (watchId != null){
      navigator.geolocation.clearWatch(watchId);
      watchId = null;
    }
  }

  function applyTrackingDesiredState(){
    setTrackingBtn();
    if (trackingOn) startTracking();
    else stopTracking();
  }

  // Some browsers require a user gesture for GPS
  let trackingArmed = true;
  function armTrackingOnce(){
    if (!trackingArmed) return;
    trackingArmed = false;
    if (trackingOn) startTracking();
    window.removeEventListener("pointerdown", armTrackingOnce, true);
  }

  // Map click
  map.on("click", (e) => {
    const { lat, lng } = e.latlng;

    if (armSave){
      if (armSave.type === "fixed"){
        setFixedPlace(armSave.key, lat, lng);
        toast("Saved", `${armSave.key} updated.`, "ok");
      } else if (armSave.type === "custom"){
        addCustomPlace(armSave.name, lat, lng);
        toast("Saved", `"${armSave.name}" added.`, "ok");
      }
      armSave = null;
      return;
    }

    setDestination({ lat, lon: lng, name: "Pinned location", address: "" });
    toast("Pinned", "Destination pinned. Calculating route‚Ä¶", "info");
  });

  // Clear
  function clearAll(){
    results = [];
    selectedIndex = -1;
    markersLayer.clearLayers();
    if (routeLine) { routeLine.remove(); routeLine = null; }
    if (destMarker) { destMarker.remove(); destMarker = null; }
    nav.dest = null;
    stopNav();
    resultsWrap.style.display = "none";
    clearBtn.style.display = "none";
    resultsList.innerHTML = "";
    resultsMeta.textContent = "‚Äî";
    setStatus("Ready");
    updateWeatherSmart();
    cacheUiState();
  }

  // Panel slide + layout clearance for zoom
  function setPanelClearance(px){
    document.documentElement.style.setProperty("--panel-clear", px + "px");
  }

  function setPanelOpen(open){
    panelOpen = !!open;

    const desktop = window.matchMedia("(min-width: 900px)").matches;

    if (desktop){
      panel.style.transform = panelOpen ? "translateX(0)" : "translateX(110%)";
      panelRestore.classList.toggle("show", !panelOpen);
      setPanelClearance(190);
    } else {
      panel.style.transform = panelOpen ? "translateY(0)" : "translateY(78%)";
      panelRestore.classList.toggle("show", !panelOpen);
      // approximate clearance based on open state
      setPanelClearance(panelOpen ? 250 : 120);
    }

    setTimeout(()=>map.invalidateSize(), 80);
  }

  function initPanelDrag(){
    let startY = 0;
    let startTransform = 0;
    let dragging = false;

    const isDesktop = () => window.matchMedia("(min-width: 900px)").matches;

    panelHandle.addEventListener("pointerdown", (e)=>{
      dragging = true;
      panelHandle.setPointerCapture(e.pointerId);
      startY = e.clientY;

      const m = panel.style.transform.match(/translateY\(([-0-9.]+)%\)/);
      startTransform = m ? Number(m[1]) : (panelOpen ? 0 : 78);
    });

    panelHandle.addEventListener("pointermove", (e)=>{
      if (!dragging) return;
      if (isDesktop()) return;
      const dy = e.clientY - startY;
      const percent = (dy / window.innerHeight) * 100;
      let next = startTransform + percent;
      next = Math.min(Math.max(next, 0), 82);
      panel.style.transition = "none";
      panel.style.transform = `translateY(${next}%)`;
      // update clearance continuously
      const openPct = Math.max(0, 82 - next) / 82; // rough
      const px = 120 + openPct * 170;
      setPanelClearance(Math.round(px));
    });

    panelHandle.addEventListener("pointerup", ()=>{
      if (!dragging) return;
      dragging = false;
      panel.style.transition = "transform .22s ease";
      if (isDesktop()) return;
      const m = panel.style.transform.match(/translateY\(([-0-9.]+)%\)/);
      const cur = m ? Number(m[1]) : 0;
      if (cur > 42) setPanelOpen(false);
      else setPanelOpen(true);
    });

    panelHandle.addEventListener("click", ()=>{
      if (!isDesktop()) return;
      setPanelOpen(!panelOpen);
    });
  }

  panelRestore.addEventListener("click", ()=> setPanelOpen(true));

  // Tabs
  function switchTab(name){
    tabs.forEach(t => t.classList.toggle("active", t.getAttribute("data-tab") === name));
    tab_search.style.display = (name === "search") ? "block" : "none";
    tab_explore.style.display = (name === "explore") ? "block" : "none";
    tab_saved.style.display = (name === "saved") ? "block" : "none";
    tab_settings.style.display = (name === "settings") ? "block" : "none";

    if (name === "explore"){
      // lazy load explore on first open
      if (!catRail.innerHTML) renderCatRail();
      if (!exploreItems.length) exploreFetch();
    }
  }
  tabs.forEach(t=>{
    t.addEventListener("click", ()=> switchTab(t.getAttribute("data-tab")));
  });

  // Modal helpers
  function openModal(title, html){
    modalTitle.textContent = title;
    modalBody.innerHTML = html;
    modal.style.display = "flex";
  }
  function closeModal(){ modal.style.display = "none"; }
  modalClose.addEventListener("click", closeModal);
  modal.addEventListener("click", (e)=>{ if (e.target === modal) closeModal(); });

  // Saved manager modal
  function renderSavedManager(){
    const saved = loadSaved();
    const fixed = [
      { key:"home", label:"Home", emoji:"üè†" },
      { key:"school", label:"School", emoji:"üéì" },
      { key:"work", label:"Work", emoji:"üíº" },
    ];

    const fixedHtml = fixed.map(slot => {
      const p = saved[slot.key];
      const meta = p ? `Set ¬∑ ${new Date(p.updatedAt || Date.now()).toLocaleString()}` : "Not set";
      return `
        <div class="mItem">
          <div>
            <b>${slot.emoji} ${slot.label}</b>
            <div class="meta">${escapeHtml(meta)}</div>
          </div>
          <div class="mBtns">
            <button class="btn slim" data-fixed-go="${slot.key}">Go</button>
            <button class="btn slim" data-fixed-set="${slot.key}">Set</button>
            <button class="btn slim danger" data-fixed-clear="${slot.key}">Clear</button>
          </div>
        </div>
      `;
    }).join("");

    const customHtml = (saved.custom.length ? saved.custom : []).map(item => `
      <div class="mItem">
        <div style="flex:1">
          <b>‚≠ê ${escapeHtml(item.name)}</b>
          <div class="meta">${escapeHtml(`Lat ${item.lat.toFixed(5)}, Lon ${item.lon.toFixed(5)}`)}</div>
          <div class="mRow" style="margin-top:8px;">
            <input class="mInput" data-custom-name="${item.id}" value="${escapeHtml(item.name)}" />
          </div>
        </div>
        <div class="mBtns">
          <button class="btn slim" data-custom-go="${item.id}">Go</button>
          <button class="btn slim" data-custom-update="${item.id}">Rename</button>
          <button class="btn slim danger" data-custom-del="${item.id}">Delete</button>
        </div>
      </div>
    `).join("");

    const html = `
      <div class="small" style="opacity:.95">
        Tip: select a destination then tap Home/School/Work to save instantly. Or use Set and tap the map.
      </div>

      <div class="mTitle" style="margin-top:14px">Fixed</div>
      ${fixedHtml}

      <div class="mTitle" style="margin-top:18px">Custom</div>
      <div class="mRow">
        <button class="btn slim primary" id="customAddBtn">+ Add custom place</button>
        <button class="btn slim danger" id="customClearBtn">Clear all custom</button>
      </div>
      ${customHtml || `<div class="small" style="margin-top:10px">No custom places yet.</div>`}
    `;

    openModal("Saved places", html);

    fixed.forEach(slot => {
      modalBody.querySelector(`[data-fixed-go="${slot.key}"]`)?.addEventListener("click", ()=>{
        const p = loadSaved()[slot.key];
        if (!p) return toast("Not set", `${slot.label} is not set yet.`, "info");
        setDestination({ lat:p.lat, lon:p.lon, name: slot.label, address:"" });
        closeModal();
      });
      modalBody.querySelector(`[data-fixed-set="${slot.key}"]`)?.addEventListener("click", ()=>{
        armSave = { type:"fixed", key: slot.key };
        toast("Set place", `Tap on the map to set ${slot.label}.`, "info", 5200);
        closeModal();
      });
      modalBody.querySelector(`[data-fixed-clear="${slot.key}"]`)?.addEventListener("click", ()=>{
        const s = loadSaved();
        s[slot.key] = null;
        saveSaved(s);
        toast("Cleared", `${slot.label} cleared.`, "info");
        closeModal();
      });
    });

    modalBody.querySelector("#customAddBtn")?.addEventListener("click", ()=>{
      const name = prompt("Name this place:");
      if (!name) return;
      if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
        addCustomPlace(name, nav.dest.lat, nav.dest.lon);
        toast("Saved", `"${name}" saved from selected destination.`, "ok");
        closeModal();
        return;
      }
      armSave = { type:"custom", name };
      toast("Add place", `Tap on the map to place: "${name}"`, "info", 5200);
      closeModal();
    });

    modalBody.querySelector("#customClearBtn")?.addEventListener("click", ()=>{
      if (!confirm("Delete all custom places?")) return;
      const s = loadSaved();
      s.custom = [];
      saveSaved(s);
      toast("Cleared", "All custom places deleted.", "info");
      closeModal();
    });

    (loadSaved().custom || []).forEach(item => {
      modalBody.querySelector(`[data-custom-go="${item.id}"]`)?.addEventListener("click", ()=>{
        setDestination({ lat:item.lat, lon:item.lon, name: item.name, address:"" });
        closeModal();
      });
      modalBody.querySelector(`[data-custom-update="${item.id}"]`)?.addEventListener("click", ()=>{
        const input = modalBody.querySelector(`[data-custom-name="${item.id}"]`);
        const newName = input ? input.value : item.name;
        updateCustomName(item.id, newName);
        toast("Renamed", "Custom place renamed.", "ok");
        closeModal();
      });
      modalBody.querySelector(`[data-custom-del="${item.id}"]`)?.addEventListener("click", ()=>{
        if (!confirm("Delete this place?")) return;
        deleteCustom(item.id);
        toast("Deleted", "Custom place deleted.", "info");
        closeModal();
      });
    });
  }

  // Cache UI state
  function cacheUiState(){
    try{
      const state = {
        q: qEl.value || "",
        mode: modeSel.value || "walking",
        voiceStyle: nav.voiceStyle || "off",
        followOn: !!followOn,
        trackingOn: !!trackingOn,
        lastDest: nav.dest ? { lat: nav.dest.lat, lon: nav.dest.lon, name: nav.dest.name, address: nav.dest.address } : null,
        lastResults: results.slice(0, 200),
        selectedIndex
      };
      saveJson(UI_KEY, state);
    } catch {}
  }

  function restoreUiState(){
    const state = loadJson(UI_KEY, null);
    if (!state) return;

    if (state.q) qEl.value = state.q;
    if (state.mode) modeSel.value = state.mode;
    if (state.voiceStyle) nav.voiceStyle = state.voiceStyle;
    if (typeof state.followOn === "boolean") followOn = state.followOn;
    if (typeof state.trackingOn === "boolean") trackingOn = state.trackingOn;

    updateVoiceBtn();
    navFollowBtn.textContent = followOn ? "üß≠ Follow: On" : "üß≠ Follow: Off";
    setTrackingBtn();

    if (Array.isArray(state.lastResults) && state.lastResults.length){
      results = state.lastResults
        .map(x => ({ ...x, lat:Number(x.lat), lon:Number(x.lon) }))
        .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));
      selectedIndex = Number.isFinite(state.selectedIndex) ? state.selectedIndex : -1;
      renderMarkers();
      renderResults();
    }

    if (state.lastDest && Number.isFinite(state.lastDest.lat) && Number.isFinite(state.lastDest.lon)){
      nav.dest = { ...state.lastDest };
    }
  }

  // Speech-to-search (Web Speech API)
  function startSpeechSearch(){
    const SR = window.SpeechRecognition || window.webkitSpeechRecognition;
    if (!SR){
      toast("Speech search", "Not supported on this browser.", "bad", 2600);
      return;
    }
    const rec = new SR();
    rec.lang = "el-GR"; // you can switch later in settings
    rec.interimResults = false;
    rec.maxAlternatives = 1;

    micBtn.textContent = "‚è∫Ô∏è";
    micBtn.disabled = true;

    rec.onresult = (e)=>{
      const text = e.results?.[0]?.[0]?.transcript || "";
      if (text.trim()){
        qEl.value = text.trim();
        doSearch(text.trim());
      }
    };
    rec.onerror = ()=>{
      toast("Speech search", "Could not capture audio.", "bad", 2400);
    };
    rec.onend = ()=>{
      micBtn.textContent = "üéôÔ∏è";
      micBtn.disabled = false;
    };

    try{
      rec.start();
      toast("Speech search", "Listening‚Ä¶", "info", 1200);
    } catch {
      micBtn.textContent = "üéôÔ∏è";
      micBtn.disabled = false;
    }
  }

  // Wire buttons
  btn.addEventListener("click", ()=>doSearch());
  micBtn.addEventListener("click", startSpeechSearch);

  qEl.addEventListener("keydown", (e)=>{
    if (e.key === "Enter") doSearch();
    else scheduleSuggest();
  });
  qEl.addEventListener("input", scheduleSuggest);
  qEl.addEventListener("blur", ()=> setTimeout(hideSuggest, 140));

  myLocBtn.addEventListener("click", ()=>{
    if (trackingOn && myLocation) {
      map.setView([myLocation.lat, myLocation.lon], Math.max(map.getZoom(), 15));
      toast("Centered", "Centered on your location.", "info", 1400);
      return;
    }
    if (!navigator.geolocation) return toast("Unsupported", "Your browser does not support location.", "bad");
    navigator.geolocation.getCurrentPosition(
      (pos)=>{
        const rawLat = pos.coords.latitude, rawLon = pos.coords.longitude;
        const outside = !inAthens(rawLat, rawLon);
        const use = outside ? clampToAthens(rawLat, rawLon) : { lat: rawLat, lon: rawLon };
        myLocation = myLocation || {};
        myLocation.lat = use.lat; myLocation.lon = use.lon; myLocation.bearingDeg = 0; myLocation.lastUpdate = Date.now();
        setMyMarkers(use.lat, use.lon, 0);
        map.setView([use.lat, use.lon], 15);
        toast(outside ? "Outside Athens" : "Location set", outside ? "GPS outside Athens (clamped).": "GPS acquired.", outside ? "info":"ok", 4200);
        updateWeatherSmart();
        if (nav.dest) startRoute();
        cacheUiState();
      },
      (err)=> toast("Location error", err?.message || "Could not get location.", "bad", 5200),
      { enableHighAccuracy:true, timeout:12000, maximumAge:0 }
    );
  });

  trackBtn.addEventListener("click", ()=>{
    trackingOn = !trackingOn;
    applyTrackingDesiredState();
    toast("Tracking", trackingOn ? "Live tracking enabled." : "Live tracking disabled.", "info");
    cacheUiState();
  });

  clearBtn.addEventListener("click", ()=>{
    clearAll();
    toast("Cleared", "Results and route cleared.", "info");
  });

  modeSel.addEventListener("change", ()=>{
    if (myLocation && nav.dest) startRoute();
    cacheUiState();
  });

  // Nav controls
  navPrev.addEventListener("click", ()=>{ nav.stepIndex = Math.max(0, nav.stepIndex - 1); showNavStep(); });
  navNext.addEventListener("click", ()=>{ nav.stepIndex = Math.min(nav.steps.length - 1, nav.stepIndex + 1); showNavStep(); });
  navClose.addEventListener("click", ()=>{ stopNav(); toast("Navigation ended", "Route panel closed.", "info"); });

  navVoice.addEventListener("click", ()=>{
    nav.voiceStyle = (nav.voiceStyle === "off") ? "soft" : "off";
    updateVoiceBtn();
    toast("Voice", nav.voiceStyle === "off" ? "Voice disabled." : "Soft voice enabled.", "info");
    cacheUiState();
  });

  navFollowBtn.addEventListener("click", ()=>{
    followOn = !followOn;
    navFollowBtn.textContent = followOn ? "üß≠ Follow: On" : "üß≠ Follow: Off";
    toast("Follow", followOn ? "Map will follow you." : "Follow disabled.", "info");
    cacheUiState();
  });

  navMe.addEventListener("click", ()=>{
    if (myLocation) map.setView([myLocation.lat, myLocation.lon], Math.max(map.getZoom(), 15));
    else toast("Me", "No location yet. Tap My location.", "info", 2200);
  });

  // Zoom
  zoomInBtn.addEventListener("click", ()=> map.zoomIn());
  zoomOutBtn.addEventListener("click", ()=> map.zoomOut());

  // Explore
  exploreRefresh.addEventListener("click", exploreFetch);

  // Saved tab quick actions
  savedManageBtn.addEventListener("click", renderSavedManager);

  function startSetFixed(key, label){
    if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
      setFixedPlace(key, nav.dest.lat, nav.dest.lon);
      toast("Saved", `${label} saved from selected destination.`, "ok");
      return;
    }
    armSave = { type:"fixed", key };
    toast("Set saved place", `Tap on the map to set ${label}.`, "info", 5200);
  }

  saveHomeBtn.addEventListener("click", ()=> startSetFixed("home","Home"));
  saveSchoolBtn.addEventListener("click", ()=> startSetFixed("school","School"));
  saveWorkBtn.addEventListener("click", ()=> startSetFixed("work","Work"));

  addPlaceBtn.addEventListener("click", ()=>{
    const name = prompt("Name this place (e.g., Gym, Grandma, Favorite cafe):");
    if (!name) return;

    if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
      addCustomPlace(name, nav.dest.lat, nav.dest.lon);
      toast("Saved", `"${name}" saved from selected destination.`, "ok");
      return;
    }

    armSave = { type:"custom", name };
    toast("Add place", `Tap on the map to place: "${name}"`, "info", 5200);
  });

  // Settings button opens the Settings tab + modal placeholder
  settingsBtn.addEventListener("click", ()=>{
    switchTab("settings");
    setPanelOpen(true);
  });

  voiceTestBtn.addEventListener("click", ()=>{
    nav.voiceStyle = "soft";
    updateVoiceBtn();
    speak("Test. Athens Navigator voice.");
    toast("Voice test", "If this sounds robotic, it‚Äôs your device voice. We‚Äôll add a better selector later.", "info", 3600);
  });

  resetUiBtn.addEventListener("click", ()=>{
    if (!confirm("Reset UI state? (Keeps saved places)")) return;
    localStorage.removeItem(UI_KEY);
    localStorage.removeItem(LAST_RESULTS_KEY);
    toast("Reset", "UI state cleared. Refresh the page.", "info", 2800);
  });

  // Init
  window.addEventListener("DOMContentLoaded", async ()=>{
    aboutLine.textContent = `Athens Navigator v${APP_VERSION}`;

    tickTime();
    setInterval(tickTime, 1000 * 20);

    updateOfflineHint();
    renderSavedMarkers();
    restoreUiState();

    initPanelDrag();
    setPanelOpen(true);

    applyTrackingDesiredState();
    window.addEventListener("pointerdown", armTrackingOnce, true);

    await initCompass();

    // weather initial + on map move (throttled)
    let weatherMoveT = 0;
    map.on("moveend", ()=>{
      const now = Date.now();
      if (now - weatherMoveT < 6000) return;
      weatherMoveT = now;
      updateWeatherSmart();
    });

    updateWeatherSmart();

    registerSW();

    setTimeout(()=>{ splash.classList.add("hidden"); }, 900);

    toast("Athens Navigator", `v${APP_VERSION} ready. Tap the map to pin a destination.`, "info", 2800);
  });
  </script>
</body>
</html>
