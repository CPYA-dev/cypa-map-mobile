<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1,viewport-fit=cover" />
  <title>CPYA Map (Athens) ‚Äî v1.1</title>

  <link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css">
  <script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>

  <style>
    :root{
      --bg:#0b0c10;
      --card:#111318;
      --card2:#151824;
      --text:#e8eaed;
      --muted:#aab0bb;
      --line:rgba(255,255,255,.10);
      --accent:#4aa3ff;
      --danger:#ff4d4d;
      --ok:#00d084;
      --shadow: 0 10px 30px rgba(0,0,0,.35);
      --radius: 16px;
      --radius2: 22px;
      --safe-bottom: env(safe-area-inset-bottom, 0px);
      --safe-top: env(safe-area-inset-top, 0px);
    }
    html, body { height: 100%; margin: 0; font-family: system-ui, -apple-system, Segoe UI, Roboto, Arial, sans-serif; background: #07080b; color: var(--text); }
    #app { height: 100%; display:flex; flex-direction:column; position:relative; }

    /* Map */
    #map { flex: 1; width: 100%; height: 100%; }

    /* Floating system */
    .card{
      background: rgba(17,19,24,.92);
      border: 1px solid var(--line);
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      backdrop-filter: blur(10px);
    }

    /* Panel container (desktop default is "top"; overridden below for desktop right-side) */
    #panel {
      position: relative;
      z-index: 2000;
      background: rgba(8,10,14,.75);
      border-bottom: 1px solid var(--line);
      padding: calc(10px + var(--safe-top)) 12px 10px;
    }

    #panelInner{
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }

    .input{
      flex: 1 1 220px;
      min-width: 160px;
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 16px;
      outline:none;
    }
    .btn{
      background: rgba(255,255,255,.08);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
      cursor:pointer;
      user-select:none;
    }
    .btn:hover{ background: rgba(255,255,255,.12); }
    .btn.primary{ background: rgba(74,163,255,.18); border-color: rgba(74,163,255,.35); }
    .btn.danger{ background: rgba(255,77,77,.14); border-color: rgba(255,77,77,.35); }
    .btn.ghost{ background: transparent; }

    .row{
      margin-top: 10px;
      display:flex;
      gap:10px;
      align-items:center;
      flex-wrap:wrap;
    }
    select{
      background: rgba(255,255,255,.06);
      color: var(--text);
      border: 1px solid var(--line);
      border-radius: 14px;
      padding: 12px 12px;
      font-size: 15px;
    }

    .small { font-size: 12px; color: var(--muted); }

    /* Results list */
    #resultsWrap{
      margin-top: 10px;
      display:none;
    }
    #resultsHeader{
      display:flex;
      justify-content:space-between;
      align-items:center;
      gap:10px;
      margin-bottom: 8px;
    }
    #resultsList{
      max-height: 220px;
      overflow:auto;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(255,255,255,.04);
    }
    .res{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.06);
      cursor:pointer;
    }
    .res:last-child{ border-bottom:none; }
    .res:hover{ background: rgba(255,255,255,.06); }
    .res.selected{ background: rgba(74,163,255,.16); outline: 1px solid rgba(74,163,255,.35); }
    .resTitle{ font-size: 14px; }
    .resMeta{ font-size: 12px; color: var(--muted); margin-top: 3px; }
    .pill{
      display:inline-flex;
      align-items:center;
      gap:6px;
      padding: 6px 10px;
      border-radius: 999px;
      border: 1px solid rgba(255,255,255,.12);
      background: rgba(255,255,255,.06);
      font-size: 12px;
      color: var(--text);
      user-select:none;
      cursor:pointer;
      margin-right: 6px;
      margin-top: 6px;
    }
    .pill:hover{ background: rgba(255,255,255,.10); }

    /* Suggestions dropdown */
    #suggestBox{
      position:absolute;
      top: calc(12px + var(--safe-top) + 52px);
      left: 12px;
      right: 12px;
      display:none;
      z-index: 2200;
      border-radius: 16px;
      overflow:hidden;
    }
    #suggestBox .item{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      cursor:pointer;
      background: rgba(17,19,24,.96);
    }
    #suggestBox .item:last-child{ border-bottom:none; }
    #suggestBox .item:hover{ background: rgba(255,255,255,.06); }
    #suggestBox .item .sub{ font-size:12px; color: var(--muted); margin-top:3px; }

    /* Saved places menu (More) */
    #savedMenu{
      position:absolute;
      top: calc(12px + var(--safe-top) + 96px);
      left: 12px;
      right: 12px;
      display:none;
      z-index: 2300;
      overflow:hidden;
      border-radius: 16px;
    }
    .menuItem{
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255,255,255,.08);
      background: rgba(17,19,24,.96);
      display:flex;
      gap:10px;
      align-items:center;
      justify-content:space-between;
    }
    .menuItem:last-child{ border-bottom:none; }
    .menuItem .left{
      display:flex;
      flex-direction:column;
      gap:2px;
      min-width: 0;
    }
    .menuItem .title{ font-weight: 800; font-size: 13px; }
    .menuItem .sub{ font-size: 12px; color: var(--muted); white-space:nowrap; overflow:hidden; text-overflow:ellipsis; max-width: 240px; }
    .menuItem .actions{
      display:flex; gap:8px; align-items:center; flex-wrap:wrap;
    }
    .miniBtn{
      border: 1px solid rgba(255,255,255,.14);
      background: rgba(255,255,255,.06);
      color: var(--text);
      border-radius: 12px;
      padding: 8px 10px;
      font-size: 12px;
      cursor:pointer;
      user-select:none;
      white-space:nowrap;
    }
    .miniBtn:hover{ background: rgba(255,255,255,.10); }
    .miniBtn.danger{ border-color: rgba(255,77,77,.35); background: rgba(255,77,77,.10); }

    /* Loading overlay */
    #loadingOverlay{
      position: fixed;
      inset: 0;
      display:none;
      align-items:center;
      justify-content:center;
      z-index: 5000;
      background: rgba(0,0,0,.40);
      backdrop-filter: blur(3px);
    }
    .loaderCard{
      padding: 14px 16px;
      border-radius: 18px;
      border: 1px solid var(--line);
      background: rgba(17,19,24,.92);
      box-shadow: var(--shadow);
      display:flex;
      align-items:center;
      gap:12px;
      max-width: 92vw;
    }
    .spinner{
      width: 18px; height: 18px;
      border: 2px solid rgba(255,255,255,.2);
      border-top-color: rgba(255,255,255,.9);
      border-radius: 999px;
      animation: spin 0.9s linear infinite;
    }
    @keyframes spin { to { transform: rotate(360deg); } }
    .skeleton{
      background: linear-gradient(90deg, rgba(255,255,255,.06), rgba(255,255,255,.12), rgba(255,255,255,.06));
      background-size: 200% 100%;
      animation: shimmer 1.1s infinite;
      border-radius: 10px;
    }
    @keyframes shimmer { 0%{background-position: 200% 0} 100%{background-position: -200% 0} }

    /* Toasts */
    #toastWrap{
      position: fixed;
      top: calc(12px + var(--safe-top));
      left: 50%;
      transform: translateX(-50%);
      z-index: 6000;
      display:flex;
      flex-direction:column;
      gap:8px;
      width: min(520px, 92vw);
      pointer-events:none;
    }
    .toast{
      pointer-events:auto;
      padding: 10px 12px;
      border-radius: 14px;
      border: 1px solid var(--line);
      background: rgba(17,19,24,.92);
      box-shadow: var(--shadow);
      display:flex;
      align-items:flex-start;
      gap:10px;
    }
    .toast .tTitle{ font-size: 13px; font-weight: 700; margin-bottom: 2px; }
    .toast .tMsg{ font-size: 13px; color: var(--muted); }
    .toast .x{
      margin-left:auto;
      cursor:pointer;
      opacity:.8;
      user-select:none;
    }
    .toast.ok{ border-color: rgba(0,208,132,.35); }
    .toast.bad{ border-color: rgba(255,77,77,.35); }
    .toast.info{ border-color: rgba(74,163,255,.35); }

    /* Floating weather (bottom-left) */
    #weatherCard{
      position: fixed;
      left: 12px;
      bottom: calc(12px + var(--safe-bottom));
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 16px;
      display:none;
      min-width: 180px;
      max-width: min(320px, 80vw);
    }
    #weatherCard .line{ font-size: 13px; color: var(--muted); margin-top: 2px; }
    #weatherCard .big{ font-size: 18px; font-weight: 800; }
    #weatherCard .tiny{ font-size: 11px; color: var(--muted); margin-top: 6px; }

    /* Turn-by-turn card (bottom-center) */
    #navCard{
      position: fixed;
      left: 50%;
      transform: translateX(-50%);
      bottom: calc(12px + var(--safe-bottom));
      z-index: 1200;
      padding: 10px 12px;
      border-radius: 18px;
      display:none;
      width: min(560px, 92vw);
    }
    #navTop{
      display:flex;
      align-items:center;
      justify-content:space-between;
      gap:10px;
      margin-bottom: 6px;
    }
    #navInstr{
      font-size: 15px;
      font-weight: 800;
      line-height: 1.2;
    }
    #navSub{
      font-size: 12px;
      color: var(--muted);
      margin-top: 3px;
    }
    #navBtns{
      display:flex;
      gap:8px;
      align-items:center;
      flex-wrap:wrap;
      margin-top: 10px;
    }

    /* Mobile: panel becomes bottom sheet */
    @media (max-width: 720px){
      #panel{
        position: fixed;
        left: 0;
        right: 0;
        bottom: 0;
        top: auto;
        border-bottom: none;
        border-top: 1px solid var(--line);
        padding: 10px 12px calc(10px + var(--safe-bottom));
        background: rgba(8,10,14,.90);
        z-index: 2000;
        border-top-left-radius: var(--radius2);
        border-top-right-radius: var(--radius2);
      }
      #panelHandle{
        width: 44px;
        height: 5px;
        border-radius: 999px;
        background: rgba(255,255,255,.22);
        margin: 4px auto 10px;
      }
      #resultsList{ max-height: 170px; }
      #suggestBox{
        top: auto;
        bottom: calc(10px + var(--safe-bottom) + 110px);
      }
      #savedMenu{
        top: auto;
        bottom: calc(10px + var(--safe-bottom) + 160px);
      }
      /* avoid overlapping with bottom sheet */
      #weatherCard{ bottom: calc(12px + var(--safe-bottom) + 220px); }
      #navCard{ bottom: calc(12px + var(--safe-bottom) + 220px); }
    }

    /* Desktop: panel on the RIGHT (PC only) */
    @media (min-width: 721px){
      #panel{
        position: fixed;
        top: calc(12px + var(--safe-top));
        right: 12px;
        left: auto;
        width: 380px;
        border: 1px solid var(--line);
        border-radius: var(--radius2);
        background: rgba(8,10,14,.80);
        padding: 12px;
      }
      #panelHandle{ display:none; }
      #suggestBox{
        top: 62px;
        left: 12px;
        right: 12px;
      }
      #savedMenu{
        top: 118px;
        left: 12px;
        right: 12px;
      }
    }
  </style>
</head>

<body>
  <div id="toastWrap"></div>

  <div id="loadingOverlay">
    <div class="loaderCard">
      <div class="spinner"></div>
      <div>
        <div style="font-weight:800">Working‚Ä¶</div>
        <div style="font-size:13px;color:var(--muted)" id="loadingText">Loading</div>
      </div>
    </div>
  </div>

  <div id="weatherCard" class="card"></div>

  <div id="navCard" class="card">
    <div id="navTop">
      <div>
        <div id="navInstr">‚Äî</div>
        <div id="navSub">‚Äî</div>
      </div>
      <button class="btn ghost" id="navClose" title="End navigation">‚úï</button>
    </div>
    <div id="navBtns">
      <button class="btn" id="navPrev">‚óÄ Prev</button>
      <button class="btn primary" id="navNext">Next ‚ñ∂</button>
      <button class="btn" id="navVoice">üîà Voice: Off</button>
      <button class="btn" id="navCenter">üìç Center</button>
    </div>
  </div>

  <div id="app">
    <div id="panel">
      <div id="panelHandle"></div>

      <div id="panelInner">
        <input id="q" class="input" placeholder='Search‚Ä¶' autocomplete="off" />
        <button id="btn" class="btn primary" type="button">Find</button>
        <button id="locBtn" class="btn" type="button">My location</button>
        <button id="togglePanel" class="btn" type="button" title="Collapse/expand">‚ñæ</button>
      </div>

      <div id="suggestBox" class="card"></div>
      <div id="savedMenu" class="card"></div>

      <div id="panelBody">
        <div class="row" id="menuRow">
          <select id="nearSel">
            <option value="cafe">‚òï Cafes near me</option>
            <option value="food">üçï Food near me</option>
            <option value="pharmacy">üíä Pharmacies near me</option>
            <option value="supermarket">üõí Supermarkets near me</option>
          </select>
          <button id="nearBtn" class="btn" type="button">Near me</button>

          <select id="modeSel">
            <option value="walking">üö∂ Walking</option>
            <option value="driving">üöó Driving</option>
          </select>

          <button id="clearBtn" class="btn danger" type="button" style="display:none;">Clear</button>
          <span class="small" id="status">Ready</span>
        </div>

        <div id="chips"></div>

        <div id="resultsWrap">
          <div id="resultsHeader">
            <div style="font-weight:800">Results</div>
            <div class="small" id="resultsMeta">‚Äî</div>
          </div>
          <div id="resultsList"></div>
        </div>
      </div>
    </div>

    <div id="map"></div>
  </div>

  <script>
    // =========================
    // Athens bounds
    // =========================
    const ATHENS_BBOX = { west: 23.45, south: 37.75, east: 24.25, north: 38.20 };

    const ATHENS_BOUNDS = L.latLngBounds(
      [ATHENS_BBOX.south, ATHENS_BBOX.west],
      [ATHENS_BBOX.north, ATHENS_BBOX.east]
    );

    function inAthens(lat, lon) {
      return lon >= ATHENS_BBOX.west && lon <= ATHENS_BBOX.east &&
             lat >= ATHENS_BBOX.south && lat <= ATHENS_BBOX.north;
    }

    function clampToAthens(lat, lon){
      const clampedLat = Math.min(Math.max(lat, ATHENS_BBOX.south), ATHENS_BBOX.north);
      const clampedLon = Math.min(Math.max(lon, ATHENS_BBOX.west), ATHENS_BBOX.east);
      return { lat: clampedLat, lon: clampedLon };
    }

    // =========================
    // DOM
    // =========================
    const qEl = document.getElementById("q");
    const btn = document.getElementById("btn");
    const locBtn = document.getElementById("locBtn");
    const togglePanelBtn = document.getElementById("togglePanel");
    const panelBody = document.getElementById("panelBody");

    const nearSel = document.getElementById("nearSel");
    const nearBtn = document.getElementById("nearBtn");
    const modeSel = document.getElementById("modeSel");

    const statusEl = document.getElementById("status");
    const chipsEl = document.getElementById("chips");

    const resultsWrap = document.getElementById("resultsWrap");
    const resultsList = document.getElementById("resultsList");
    const resultsMeta = document.getElementById("resultsMeta");
    const clearBtn = document.getElementById("clearBtn");

    const suggestBox = document.getElementById("suggestBox");
    const savedMenu = document.getElementById("savedMenu");

    const loadingOverlay = document.getElementById("loadingOverlay");
    const loadingText = document.getElementById("loadingText");
    const toastWrap = document.getElementById("toastWrap");

    const weatherCard = document.getElementById("weatherCard");

    const navCard = document.getElementById("navCard");
    const navInstr = document.getElementById("navInstr");
    const navSub = document.getElementById("navSub");
    const navPrev = document.getElementById("navPrev");
    const navNext = document.getElementById("navNext");
    const navClose = document.getElementById("navClose");
    const navVoice = document.getElementById("navVoice");
    const navCenter = document.getElementById("navCenter");

    // =========================
    // Random placeholder examples
    // =========================
    const PLACEHOLDERS = [
      'Search: "lidl" / "pharmacy neapoli"',
      'Search: "coffee" / "souvlaki pangrati"',
      'Search: "supermarket" / "metro station"',
      'Search: "ŒöŒ§ŒïŒõ" / "œÄŒ±ŒΩŒµœÄŒπœÉœÑŒÆŒºŒπŒø"',
      'Search: "gym" / "hospital"',
      'Search: "bakery" / "piraeus port"'
    ];
    function setRandomPlaceholder(){
      const pick = PLACEHOLDERS[Math.floor(Math.random()*PLACEHOLDERS.length)];
      qEl.placeholder = pick;
    }

    // =========================
    // Map
    // =========================
    const map = L.map("map", {
      maxBounds: ATHENS_BOUNDS,
      maxBoundsViscosity: 0.65
    }).fitBounds(ATHENS_BOUNDS);

    map.setMinZoom(map.getZoom() - 2);

    L.tileLayer("https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png", { maxZoom: 19 }).addTo(map);

    const markersLayer = L.layerGroup().addTo(map);
    let myMarker = null;
    let destMarker = null;
    let routeLine = null;

    // =========================
    // State
    // =========================
    let collapsed = false;

    let myLocation = null;  // {lat, lon, rawOutside:boolean}
    let results = [];
    let selectedIndex = -1;

    let nav = {
      mode: "walking",
      dest: null,
      steps: [],
      stepIndex: 0,
      distanceM: null,
      durationS: null,
      durationSource: null,
      voiceOn: false
    };

    // Saved place "arming": user clicks Set Home then clicks map
    let armSaveKey = null; // "home" | "school" | "work" | "custom"

    // =========================
    // Utils
    // =========================
    function escapeHtml(s) {
      return String(s).replace(/[&<>"']/g, m => ({
        "&":"&amp;","<":"&lt;",">":"&gt;",'"':"&quot;","'":"&#39;"
      }[m]));
    }

    function formatDistanceMeters(m){
      if (!Number.isFinite(m)) return "‚Äî";
      if (m < 1000) return `${Math.round(m)} m`;
      return `${(m/1000).toFixed(1)} km`;
    }

    function formatDuration(s){
      if (!Number.isFinite(s)) return "‚Äî";
      const min = Math.round(s/60);
      if (min < 60) return `${min} min`;
      const h = Math.floor(min/60);
      const rem = min % 60;
      return `${h} h ${rem} min`;
    }

    function setLoading(on, text="Working‚Ä¶"){
      loadingText.textContent = text;
      loadingOverlay.style.display = on ? "flex" : "none";
    }

    function toast(title, msg, type="info", ms=3200){
      const el = document.createElement("div");
      el.className = `toast ${type}`;
      el.innerHTML = `
        <div>
          <div class="tTitle">${escapeHtml(title)}</div>
          <div class="tMsg">${escapeHtml(msg)}</div>
        </div>
        <div class="x">‚úï</div>
      `;
      el.querySelector(".x").addEventListener("click", () => el.remove());
      toastWrap.appendChild(el);
      setTimeout(() => { if (el.isConnected) el.remove(); }, ms);
    }

    function setStatus(s){ statusEl.textContent = s; }

    // Distance math
    function haversineMeters(lat1, lon1, lat2, lon2) {
      const R = 6371000;
      const toRad = (x) => x * Math.PI / 180;
      const dLat = toRad(lat2 - lat1);
      const dLon = toRad(lon2 - lon1);
      const a =
        Math.sin(dLat / 2) ** 2 +
        Math.cos(toRad(lat1)) * Math.cos(toRad(lat2)) * Math.sin(dLon / 2) ** 2;
      const c = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));
      return R * c;
    }

    // =========================
    // Saved Places (Home/School/Work/Custom + More menu)
    // =========================
    const SAVED_KEY  = "cpya_saved_places_v11";
    const RECENT_KEY = "cpya_recent_searches_v11";

    const SAVED_SLOTS = [
      { key:"home",   label:"Home",   icon:"üè†" },
      { key:"school", label:"School", icon:"üéì" },
      { key:"work",   label:"Work",   icon:"üíº" },
      { key:"custom", label:"Custom", icon:"‚≠ê" }
    ];

    function loadJson(key, fallback){
      try{ const v = JSON.parse(localStorage.getItem(key) || ""); return v ?? fallback; }
      catch{ return fallback; }
    }
    function saveJson(key, value){
      localStorage.setItem(key, JSON.stringify(value));
    }

    function loadSaved(){
      const o = loadJson(SAVED_KEY, {});
      return (o && typeof o === "object") ? o : {};
    }
    function saveSaved(o){
      saveJson(SAVED_KEY, o);
      renderChips();
      renderSavedMenu(); // keep in sync if open
    }

    function setSavedPlace(key, lat, lon){
      const saved = loadSaved();
      saved[key] = { lat, lon, updatedAt: Date.now() };
      saveSaved(saved);
    }

    function clearSavedPlace(key){
      const saved = loadSaved();
      delete saved[key];
      saveSaved(saved);
    }

    function formatCoord(lat, lon){
      return `${lat.toFixed(5)}, ${lon.toFixed(5)}`;
    }

    function toggleSavedMenu(force){
      const show = (typeof force === "boolean") ? force : (savedMenu.style.display !== "block");
      if (show){
        hideSuggest();
        renderSavedMenu();
        savedMenu.style.display = "block";
      } else {
        savedMenu.style.display = "none";
      }
    }

    function renderSavedMenu(){
      const saved = loadSaved();
      savedMenu.innerHTML = SAVED_SLOTS.map(slot=>{
        const p = saved[slot.key];
        const has = p && Number.isFinite(p.lat) && Number.isFinite(p.lon);

        const sub = has ? `Saved at ${formatCoord(p.lat, p.lon)}` : "Not set";
        const goBtn = has ? `<button class="miniBtn" data-go="${slot.key}">Go</button>` : "";
        const setBtn = `<button class="miniBtn" data-set="${slot.key}">Set</button>`;
        const clrBtn = has ? `<button class="miniBtn danger" data-clr="${slot.key}">Clear</button>` : "";

        return `
          <div class="menuItem">
            <div class="left">
              <div class="title">${slot.icon} ${escapeHtml(slot.label)}</div>
              <div class="sub">${escapeHtml(sub)}</div>
            </div>
            <div class="actions">
              ${goBtn}
              ${setBtn}
              ${clrBtn}
            </div>
          </div>
        `;
      }).join("");

      savedMenu.querySelectorAll("[data-go]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const key = btn.getAttribute("data-go");
          const saved = loadSaved();
          const p = saved[key];
          if (!p) return;
          setDestination({ lat:p.lat, lon:p.lon, name: key, address:"" });
          toggleSavedMenu(false);
        });
      });

      savedMenu.querySelectorAll("[data-set]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const key = btn.getAttribute("data-set");
          armSaveKey = key;

          // If user already selected a destination (from search), we can set immediately
          if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
            setSavedPlace(key, nav.dest.lat, nav.dest.lon);
            toast("Saved", `${key} saved from selected destination.`, "ok");
            armSaveKey = null;
            return;
          }

          toast("Set place", `Now tap the map to set ${key}.`, "info", 5200);
        });
      });

      savedMenu.querySelectorAll("[data-clr]").forEach(btn=>{
        btn.addEventListener("click", ()=>{
          const key = btn.getAttribute("data-clr");
          clearSavedPlace(key);
          toast("Cleared", `${key} cleared.`, "info");
        });
      });
    }

    // Recents
    function loadRecent(){
      const arr = loadJson(RECENT_KEY, []);
      return Array.isArray(arr) ? arr : [];
    }
    function saveRecent(q){
      const cur = loadRecent().filter(x => String(x).toLowerCase() !== String(q).toLowerCase());
      cur.unshift(q);
      saveJson(RECENT_KEY, cur.slice(0, 8));
      renderChips();
    }

    function renderChips(){
      const rec = loadRecent();
      const saved = loadSaved();

      const homeSet = !!saved.home;
      const schoolSet = !!saved.school;

      const parts = [];

      // Home + School pills
      parts.push(`<span class="pill" data-slot="home">${homeSet ? "üè† Home" : "+ Set Home"}</span>`);
      parts.push(`<span class="pill" data-slot="school">${schoolSet ? "üéì School" : "+ Set School"}</span>`);

      // More menu pill
      parts.push(`<span class="pill" data-more="1">More ‚ñæ</span>`);

      // recents
      rec.slice(0,6).forEach((s,i) => parts.push(`<span class="pill" data-recent="${i}">${escapeHtml(s)}</span>`));
      chipsEl.innerHTML = parts.join("");

      chipsEl.querySelectorAll("[data-recent]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const idx = Number(el.getAttribute("data-recent"));
          const q = rec[idx];
          qEl.value = q;
          doSearch(q);
        });
      });

      chipsEl.querySelectorAll("[data-more]").forEach(el=>{
        el.addEventListener("click", ()=> toggleSavedMenu() );
      });

      chipsEl.querySelectorAll("[data-slot]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const key = el.getAttribute("data-slot");
          const saved = loadSaved();
          const p = saved[key];

          if (p){
            setDestination({ lat:p.lat, lon:p.lon, name: key, address:"" });
            return;
          }

          // Not set -> arm map click (or use selected destination)
          armSaveKey = key;

          if (nav.dest && Number.isFinite(nav.dest.lat) && Number.isFinite(nav.dest.lon)){
            setSavedPlace(key, nav.dest.lat, nav.dest.lon);
            toast("Saved", `${key} saved from selected destination.`, "ok");
            armSaveKey = null;
            return;
          }

          toast("Set place", `Now tap the map to set ${key}.`, "info", 5200);
        });
      });
    }

    // Hide menus on outside interactions
    function hideSuggest(){ suggestBox.style.display="none"; }
    function hideSavedMenu(){ savedMenu.style.display="none"; }

    document.addEventListener("click", (e)=>{
      // close saved menu if clicking outside panel/menu button
      const withinPanel = e.target.closest("#panel");
      if (!withinPanel){
        hideSuggest();
        hideSavedMenu();
      }
    });

    // =========================
    // Weather (unchanged logic)
    // =========================
    function weatherIcon(code) {
      code = Number(code);
      if (code === 0) return "‚òÄÔ∏è";
      if (code <= 2) return "‚õÖ";
      if (code === 3) return "‚òÅÔ∏è";
      if ((code >= 51 && code <= 57) || (code >= 61 && code <= 67) || (code >= 80 && code <= 82)) return "üåßÔ∏è";
      if ((code >= 71 && code <= 77) || code === 85 || code === 86) return "‚ùÑÔ∏è";
      if (code === 45 || code === 48) return "üå´Ô∏è";
      if (code >= 95) return "‚õàÔ∏è";
      return "üå¶Ô∏è";
    }

    async function updateWeather(lat, lon){
      weatherCard.style.display = "block";
      weatherCard.innerHTML = `
        <div style="font-weight:800">Weather</div>
        <div class="line"><span class="skeleton" style="display:inline-block;width:140px;height:14px"></span></div>
        <div class="line"><span class="skeleton" style="display:inline-block;width:110px;height:12px"></span></div>
      `;

      try{
        const r = await fetch(`/weather?lat=${encodeURIComponent(lat)}&lon=${encodeURIComponent(lon)}`);
        const d = await r.json();
        if (!d?.ok || !d?.data?.current) throw new Error("weather unavailable");

        const c = d.data.current;
        const icon = weatherIcon(c.weather_code);

        weatherCard.innerHTML = `
          <div style="display:flex;align-items:center;gap:8px;">
            <div style="font-weight:900">Weather</div>
            <div style="opacity:.9">${icon}</div>
          </div>
          <div class="big">${Math.round(c.temperature_2m)}¬∞C <span class="small">(feels ${Math.round(c.apparent_temperature)}¬∞C)</span></div>
          <div class="line">Wind ${Math.round(c.wind_speed_10m)} km/h</div>
          <div class="tiny">${escapeHtml(String(c.time||"").replace("T"," "))}</div>
        `;
      } catch {
        weatherCard.innerHTML = `
          <div style="font-weight:800">Weather</div>
          <div class="line" style="color:rgba(255,77,77,.9)">Unavailable</div>
        `;
      }
    }

    // =========================
    // Voice: less creepy + better Greek handling
    // =========================
    let cachedVoices = [];
    function refreshVoices(){
      cachedVoices = (window.speechSynthesis && speechSynthesis.getVoices) ? speechSynthesis.getVoices() : [];
    }
    if ("speechSynthesis" in window){
      refreshVoices();
      speechSynthesis.onvoiceschanged = refreshVoices;
    }

    function pickBestVoice(){
      if (!cachedVoices.length) refreshVoices();
      // Prefer Greek voices
      const greek = cachedVoices.find(v => (v.lang || "").toLowerCase().startsWith("el"));
      if (greek) return greek;

      // fallback: English
      const en = cachedVoices.find(v => (v.lang || "").toLowerCase().startsWith("en"));
      return en || null;
    }

    function stripGreekIfNoGreekVoice(text){
      const v = pickBestVoice();
      const hasGreekVoice = v && (v.lang || "").toLowerCase().startsWith("el");
      if (hasGreekVoice) return text;
      // remove greek characters to avoid butcher in en voice
      return String(text).replace(/[\u0370-\u03FF\u1F00-\u1FFF]+/g, "").replace(/\s+/g," ").trim();
    }

    function speak(text){
      try{
        if (!("speechSynthesis" in window)) return;
        const voice = pickBestVoice();
        const cleaned = stripGreekIfNoGreekVoice(text);
        if (!cleaned) return;

        window.speechSynthesis.cancel();
        const u = new SpeechSynthesisUtterance(cleaned);

        if (voice){
          u.voice = voice;
          u.lang = voice.lang || (cleaned.match(/[\u0370-\u03FF\u1F00-\u1FFF]/) ? "el-GR" : "en-US");
        } else {
          u.lang = "en-US";
        }

        // less robotic
        u.rate = 1.02;
        u.pitch = 1.0;
        u.volume = 1.0;

        window.speechSynthesis.speak(u);
      } catch {}
    }

    // =========================
    // Destination + routing
    // =========================
    function setDestination(x, opts={}){
      if (!x) return;

      let dest = { ...x };
      if (!inAthens(dest.lat, dest.lon)){
        const c = clampToAthens(dest.lat, dest.lon);
        dest.lat = c.lat; dest.lon = c.lon;
        toast("Outside Athens", "Pinned outside the Athens area. Clamped inside bounds.", "info");
      }

      nav.dest = dest;

      if (destMarker) destMarker.remove();
      destMarker = L.marker([dest.lat, dest.lon]).addTo(map)
        .bindPopup(`<b>${escapeHtml(dest.name||"Destination")}</b>`).openPopup();

      map.setView([dest.lat, dest.lon], Math.max(map.getZoom(), 15));

      updateWeather(dest.lat, dest.lon);

      if (myLocation){
        startRoute();
      } else {
        stopNav(true);
      }

      cacheUiState();
    }

    function buildInstruction(step){
      const m = step.maneuver || {};
      const type = (m.type || "").toLowerCase();
      const mod  = (m.modifier || "").toLowerCase();
      const name = step.name ? ` onto ${step.name}` : "";

      if (type === "depart") return `Start${name}`;
      if (type === "arrive") return `Arrive at destination`;
      if (type === "roundabout") return `At roundabout, take exit${name}`;
      if (type === "merge") return `Merge${name}`;
      if (type === "on ramp") return `Take the ramp${name}`;
      if (type === "off ramp") return `Exit the ramp${name}`;

      if (type === "turn"){
        if (mod) return `Turn ${mod}${name}`;
        return `Turn${name}`;
      }

      if (type === "continue" || type === "new name" || type === "straight"){
        return `Continue${name}`;
      }

      if (type === "fork"){
        if (mod) return `Keep ${mod}${name}`;
        return `Keep${name}`;
      }

      return step.name ? `Go on ${step.name}` : "Continue";
    }

    // Always different walking/driving ETA: we compute duration from distance
    function estimateDurationSeconds(distanceM, mode){
      // city-realistic baselines
      const walkingMps = 4.8 * 1000 / 3600; // 4.8 km/h
      const drivingMps = 25  * 1000 / 3600; // 25 km/h baseline in Athens traffic
      const mps = (mode === "driving") ? drivingMps : walkingMps;
      return distanceM / mps;
    }

    async function startRoute(){
      if (!myLocation || !nav.dest) return;
      nav.mode = modeSel.value || "walking";
      setStatus("Calculating route‚Ä¶");

      navCard.style.display = "block";
      navInstr.textContent = "Calculating route‚Ä¶";
      navSub.innerHTML = `<span class="skeleton" style="display:inline-block;width:220px;height:12px"></span>`;

      try{
        const url =
          `https://router.project-osrm.org/route/v1/${nav.mode}/` +
          `${myLocation.lon},${myLocation.lat};${nav.dest.lon},${nav.dest.lat}` +
          `?overview=full&geometries=geojson&steps=true`;

        const r = await fetch(url);
        const j = await r.json();
        const route = j.routes?.[0];
        if (!route) throw new Error("no route");

        const coords = route.geometry?.coordinates || [];
        const latlngs = coords.map(c => [c[1], c[0]]);
        if (routeLine) routeLine.remove();
        routeLine = L.polyline(latlngs).addTo(map);

        const leg = route.legs?.[0];
        const steps = Array.isArray(leg?.steps) ? leg.steps : [];

        nav.steps = steps.map(s => ({
          distance: s.distance,
          duration: s.duration,
          name: s.name || "",
          maneuver: s.maneuver || {},
          instruction: buildInstruction(s)
        }));

        nav.stepIndex = 0;
        nav.distanceM = route.distance;

        // Force ETA difference
        nav.durationSource = route.duration;
        nav.durationS = estimateDurationSeconds(nav.distanceM, nav.mode);

        setStatus(`Route: ${formatDistanceMeters(nav.distanceM)} ‚Ä¢ ~${formatDuration(nav.durationS)} (${nav.mode})`);
        showNavStep();

        cacheUiState();
      } catch {
        setStatus("Route failed.");
        toast("Route error", "Could not calculate route. Try again.", "bad");
        stopNav(true);
      }
    }

    function showNavStep(){
      if (!nav.steps.length){
        stopNav(true);
        return;
      }
      navCard.style.display = "block";

      const i = Math.min(Math.max(nav.stepIndex, 0), nav.steps.length - 1);
      nav.stepIndex = i;

      const s = nav.steps[i];
      navInstr.textContent = s.instruction;

      const totalEta = formatDuration(nav.durationS);
      navSub.textContent =
        `Step ${i+1}/${nav.steps.length} ¬∑ ${formatDistanceMeters(s.distance)} ¬∑ Total ${formatDistanceMeters(nav.distanceM)} ¬∑ ~${totalEta} (${nav.mode})`;

      navPrev.disabled = (i === 0);
      navNext.disabled = (i === nav.steps.length - 1);

      if (nav.voiceOn) speak(s.instruction);

      const loc = s.maneuver?.location;
      if (Array.isArray(loc) && loc.length === 2){
        map.panTo([loc[1], loc[0]], { animate:true });
      }
    }

    function stopNav(keepCard=false){
      nav.steps = [];
      nav.stepIndex = 0;
      nav.distanceM = null;
      nav.durationS = null;
      nav.durationSource = null;
      if (!keepCard) navCard.style.display = "none";
    }

    // =========================
    // Search + Nearby + Suggestions
    // =========================
    let suggestTimer = null;

    async function fetchSuggestions(q){
      if (!q || q.length < 2) { suggestBox.style.display="none"; return; }

      try{
        const r = await fetch("/where", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ q })
        });
        const d = await r.json();
        const list = Array.isArray(d?.top5) ? d.top5 : (Array.isArray(d?.results) ? d.results.slice(0,5) : []);
        const inBox = list
          .filter(x => Number.isFinite(Number(x.lat)) && Number.isFinite(Number(x.lon)))
          .map(x => ({ ...x, lat:Number(x.lat), lon:Number(x.lon) }))
          .filter(x => inAthens(x.lat, x.lon))
          .slice(0,5);

        if (!inBox.length) { suggestBox.style.display="none"; return; }

        suggestBox.innerHTML = inBox.map((x,i)=>`
          <div class="item" data-sug="${i}">
            <div>${escapeHtml(x.name || "Place")}</div>
            <div class="sub">${escapeHtml(x.address || "")}</div>
          </div>
        `).join("");
        suggestBox.style.display="block";

        suggestBox.querySelectorAll("[data-sug]").forEach(el=>{
          el.addEventListener("click", ()=>{
            const idx = Number(el.getAttribute("data-sug"));
            const pick = inBox[idx];
            suggestBox.style.display="none";
            qEl.value = pick.name || q;
            setDestination(pick);
          });
        });
      } catch {
        suggestBox.style.display="none";
      }
    }

    function scheduleSuggest(){
      clearTimeout(suggestTimer);
      const q = qEl.value.trim();
      suggestTimer = setTimeout(()=>fetchSuggestions(q), 220);
    }

    function showSearchSkeleton(){
      resultsWrap.style.display = "block";
      clearBtn.style.display = "inline-flex";
      resultsMeta.textContent = "Searching‚Ä¶";
      resultsList.innerHTML = Array.from({length:5}).map(()=>`
        <div class="res">
          <div class="skeleton" style="height:14px;width:70%"></div>
          <div class="skeleton" style="height:12px;width:90%;margin-top:8px"></div>
        </div>
      `).join("");
    }

    async function doSearch(qOverride=null){
      const q = (qOverride ?? qEl.value).trim();
      if (!q) return;

      hideSuggest();
      hideSavedMenu();
      saveRecent(q);

      setLoading(true, "Searching‚Ä¶");
      setStatus("Searching‚Ä¶");
      showSearchSkeleton();

      try{
        const r = await fetch("/where", {
          method:"POST",
          headers:{ "Content-Type":"application/json" },
          body: JSON.stringify({ q })
        });
        const d = await r.json();

        const list = Array.isArray(d?.results) ? d.results : [];
        const filtered = list
          .map(x => ({
            name: x.name,
            address: x.address,
            lat: Number(x.lat),
            lon: Number(x.lon),
            osmUrl: x.osmUrl || ""
          }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
          .filter(x => inAthens(x.lat, x.lon));

        results = filtered;
        selectedIndex = results.length ? 0 : -1;

        if (!results.length){
          setStatus("No results.");
          toast("No results", "Try a different search.", "info");
          resultsWrap.style.display = "none";
          clearBtn.style.display = "none";
          markersLayer.clearLayers();
          setLoading(false);
          return;
        }

        setStatus(`Found ${results.length} results.`);
        renderMarkers();
        renderResults();
        pickResult(0);
      } catch {
        setStatus("Network error.");
        toast("Network error", "Could not reach the server. Try again.", "bad");
      } finally {
        setLoading(false);
      }

      cacheUiState();
    }

    async function nearMe(){
      if (!myLocation){
        toast("Need location", "Tap ‚ÄúMy location‚Äù first.", "bad");
        return;
      }

      hideSuggest();
      hideSavedMenu();
      setLoading(true, "Searching near you‚Ä¶");
      setStatus("Searching near you‚Ä¶");
      showSearchSkeleton();

      try{
        const cat = nearSel.value;
        const r = await fetch(`/nearby?lat=${encodeURIComponent(myLocation.lat)}&lon=${encodeURIComponent(myLocation.lon)}&cat=${encodeURIComponent(cat)}`);
        const d = await r.json();

        const list = Array.isArray(d?.results) ? d.results : [];
        const filtered = list
          .map(x => ({
            name: x.name,
            address: x.address,
            lat: Number(x.lat),
            lon: Number(x.lon),
            osmUrl: x.osmUrl || ""
          }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon))
          .filter(x => inAthens(x.lat, x.lon));

        results = filtered;
        selectedIndex = results.length ? 0 : -1;

        if (!results.length){
          setStatus("Nothing found near you.");
          toast("No nearby results", "Try a different category.", "info");
          resultsWrap.style.display = "none";
          clearBtn.style.display = "none";
          markersLayer.clearLayers();
          setLoading(false);
          return;
        }

        setStatus(`Found ${results.length} nearby.`);
        renderMarkers();
        renderResults();
        pickResult(0);
      } catch {
        setStatus("Network error.");
        toast("Network error", "Could not fetch nearby places.", "bad");
      } finally {
        setLoading(false);
      }

      cacheUiState();
    }

    // =========================
    // Results rendering
    // =========================
    function renderResults(){
      if (!results.length){
        resultsWrap.style.display = "none";
        clearBtn.style.display = "none";
        return;
      }

      resultsWrap.style.display = "block";
      clearBtn.style.display = "inline-flex";
      resultsMeta.textContent = `${results.length} found`;

      resultsList.innerHTML = results.map((x,i)=>{
        const dist = myLocation ? formatDistanceMeters(haversineMeters(myLocation.lat, myLocation.lon, x.lat, x.lon)) : "";
        const distHtml = myLocation ? ` ¬∑ ${dist}` : "";
        const addr = x.address
          ? `<div class="resMeta">${escapeHtml(x.address)}${escapeHtml(distHtml)}</div>`
          : (myLocation ? `<div class="resMeta">${escapeHtml(dist)}</div>` : "");
        return `
          <div class="res ${i===selectedIndex ? "selected":""}" data-idx="${i}">
            <div class="resTitle">${escapeHtml(x.name || "Place")}</div>
            ${addr}
          </div>
        `;
      }).join("");

      resultsList.querySelectorAll("[data-idx]").forEach(el=>{
        el.addEventListener("click", ()=>{
          const i = Number(el.getAttribute("data-idx"));
          pickResult(i);
        });
      });
    }

    function renderMarkers(){
      markersLayer.clearLayers();
      const bounds = [];

      results.forEach((x,i)=>{
        bounds.push([x.lat, x.lon]);
        const m = L.marker([x.lat, x.lon]).addTo(markersLayer);
        m.on("click", ()=> pickResult(i));
      });

      if (bounds.length){
        map.fitBounds(bounds, { padding:[30,30] });
      }
    }

    function pickResult(i){
      const x = results[i];
      if (!x) return;
      selectedIndex = i;
      renderResults();
      setDestination(x);
    }

    // =========================
    // Location
    // =========================
    function locateMe(){
      if (!navigator.geolocation){
        toast("Unsupported", "Your browser does not support location.", "bad");
        return;
      }

      locBtn.disabled = true;
      locBtn.textContent = "Locating‚Ä¶";

      navigator.geolocation.getCurrentPosition(
        (pos) => {
          const rawLat = pos.coords.latitude;
          const rawLon = pos.coords.longitude;

          const outside = !inAthens(rawLat, rawLon);
          const use = outside ? clampToAthens(rawLat, rawLon) : { lat: rawLat, lon: rawLon };

          myLocation = { lat: use.lat, lon: use.lon, rawOutside: outside, rawLat, rawLon };

          if (myMarker) myMarker.remove();
          myMarker = L.circleMarker([use.lat, use.lon], { radius: 8 }).addTo(map)
            .bindPopup(outside ? "Your location is outside Athens (clamped inside Athens bounds)" : "You are here");

          map.setView([use.lat, use.lon], 14);

          locBtn.disabled = false;
          locBtn.textContent = "My location";

          if (outside){
            toast("Outside Athens", "GPS is outside Athens. Kept inside Athens area.", "info", 5200);
          } else {
            toast("Location set", "GPS acquired.", "ok");
          }

          if (nav.dest) startRoute();
          cacheUiState();
        },
        (err) => {
          locBtn.disabled = false;
          locBtn.textContent = "My location";
          if (err?.code === 1){
            toast("Location denied", "Allow location to use routing & near-me.", "bad", 5200);
          } else {
            toast("Location error", err?.message || "Could not get location.", "bad", 5200);
          }
        },
        { enableHighAccuracy: true, timeout: 12000, maximumAge: 0 }
      );
    }

    // =========================
    // Panel collapse
    // =========================
    function setCollapsed(state){
      collapsed = !!state;
      panelBody.style.display = collapsed ? "none" : "block";
      togglePanelBtn.textContent = collapsed ? "‚ñ∏" : "‚ñæ";
      setTimeout(()=>map.invalidateSize(), 50);
    }

    // =========================
    // Clear
    // =========================
    function clearAll(){
      results = [];
      selectedIndex = -1;
      markersLayer.clearLayers();
      if (routeLine) { routeLine.remove(); routeLine = null; }
      if (destMarker) { destMarker.remove(); destMarker = null; }
      stopNav();
      resultsWrap.style.display = "none";
      clearBtn.style.display = "none";
      resultsList.innerHTML = "";
      resultsMeta.textContent = "‚Äî";
      setStatus("Ready");
    }

    // =========================
    // Map click behavior:
    // - If armSaveKey is active: save that slot to clicked point
    // - Else: set destination as pin + route
    // =========================
    map.on("click", (e) => {
      const { lat, lng } = e.latlng;

      if (armSaveKey){
        setSavedPlace(armSaveKey, lat, lng);
        toast("Saved", `${armSaveKey} saved from map click.`, "ok");
        armSaveKey = null;
        return;
      }

      setDestination({ lat, lon: lng, name: "Pinned location", address: "" }, { fromMapClick: true });
      toast("Pinned", "Destination pinned. Calculating route‚Ä¶", "info");
    });

    // =========================
    // Cache UI
    // =========================
    const UI_KEY = "cpya_ui_state_v11";
    function cacheUiState(){
      try{
        const state = {
          q: qEl.value || "",
          mode: modeSel.value || "walking",
          lastDest: nav.dest ? { lat: nav.dest.lat, lon: nav.dest.lon, name: nav.dest.name, address: nav.dest.address } : null,
          lastResults: results.slice(0, 20),
          selectedIndex,
          voiceOn: !!nav.voiceOn
        };
        saveJson(UI_KEY, state);
      } catch {}
    }

    function restoreUiState(){
      const state = loadJson(UI_KEY, null);
      if (!state) return;

      if (state.q) qEl.value = state.q;
      if (state.mode) modeSel.value = state.mode;
      nav.voiceOn = !!state.voiceOn;
      navVoice.textContent = nav.voiceOn ? "üîà Voice: On" : "üîà Voice: Off";

      if (Array.isArray(state.lastResults) && state.lastResults.length){
        results = state.lastResults
          .map(x => ({ ...x, lat:Number(x.lat), lon:Number(x.lon) }))
          .filter(x => Number.isFinite(x.lat) && Number.isFinite(x.lon));
        selectedIndex = Number.isFinite(state.selectedIndex) ? state.selectedIndex : -1;
        renderMarkers();
        renderResults();
      }

      if (state.lastDest && Number.isFinite(state.lastDest.lat) && Number.isFinite(state.lastDest.lon)){
        nav.dest = { ...state.lastDest };
        updateWeather(nav.dest.lat, nav.dest.lon);
      }
    }

    // =========================
    // Navigation buttons
    // =========================
    navPrev.addEventListener("click", ()=>{ nav.stepIndex = Math.max(0, nav.stepIndex - 1); showNavStep(); });
    navNext.addEventListener("click", ()=>{ nav.stepIndex = Math.min(nav.steps.length - 1, nav.stepIndex + 1); showNavStep(); });
    navClose.addEventListener("click", ()=>{ stopNav(); toast("Navigation ended", "Route panel closed.", "info"); });
    navVoice.addEventListener("click", ()=>{
      nav.voiceOn = !nav.voiceOn;
      navVoice.textContent = nav.voiceOn ? "üîà Voice: On" : "üîà Voice: Off";
      toast("Voice", nav.voiceOn ? "Voice enabled." : "Voice disabled.", "info");
      cacheUiState();
    });
    navCenter.addEventListener("click", ()=>{
      if (myLocation) map.setView([myLocation.lat, myLocation.lon], 15);
      else map.fitBounds(ATHENS_BOUNDS, { padding:[20,20] });
    });

    // =========================
    // Init
    // =========================
    window.addEventListener("DOMContentLoaded", ()=>{
      setRandomPlaceholder();
      renderChips();
      restoreUiState();

      btn.addEventListener("click", ()=>doSearch());
      qEl.addEventListener("keydown", (e)=>{
        if (e.key === "Enter") doSearch();
        else scheduleSuggest();
      });
      qEl.addEventListener("input", scheduleSuggest);
      qEl.addEventListener("blur", ()=> setTimeout(hideSuggest, 140));

      locBtn.addEventListener("click", locateMe);
      nearBtn.addEventListener("click", nearMe);

      clearBtn.addEventListener("click", ()=>{
        clearAll();
        toast("Cleared", "Results and route cleared.", "info");
      });

      modeSel.addEventListener("change", ()=>{
        if (myLocation && nav.dest) startRoute();
        cacheUiState();
      });

      togglePanelBtn.addEventListener("click", ()=> setCollapsed(!collapsed));
    });

    // expose reroute hook for later watchPosition upgrade
    window.__cpya_reroute = () => {
      if (myLocation && nav.dest) startRoute();
    };
  </script>
</body>
</html>
